
ISR_IO.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001a  00803800  00000f60  00001014  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000f20  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000040  00008f20  00000f20  00000fd4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .bss          0000009f  0080381a  0080381a  0000102e  2**0
                  ALLOC
  4 .comment      00000030  00000000  00000000  0000102e  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001060  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 00000198  00000000  00000000  000010a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00003260  00000000  00000000  00001238  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000207d  00000000  00000000  00004498  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00001589  00000000  00000000  00006515  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000490  00000000  00000000  00007aa0  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000013a3  00000000  00000000  00007f30  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000127c  00000000  00000000  000092d3  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000198  00000000  00000000  0000a54f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	3d c0       	rjmp	.+122    	; 0x7c <__ctors_end>
   2:	00 00       	nop
   4:	56 c0       	rjmp	.+172    	; 0xb2 <__bad_interrupt>
   6:	00 00       	nop
   8:	54 c0       	rjmp	.+168    	; 0xb2 <__bad_interrupt>
   a:	00 00       	nop
   c:	52 c0       	rjmp	.+164    	; 0xb2 <__bad_interrupt>
   e:	00 00       	nop
  10:	50 c0       	rjmp	.+160    	; 0xb2 <__bad_interrupt>
  12:	00 00       	nop
  14:	4e c0       	rjmp	.+156    	; 0xb2 <__bad_interrupt>
  16:	00 00       	nop
  18:	45 c4       	rjmp	.+2186   	; 0x8a4 <__vector_6>
  1a:	00 00       	nop
  1c:	97 c4       	rjmp	.+2350   	; 0x94c <__vector_7>
  1e:	00 00       	nop
  20:	c1 c2       	rjmp	.+1410   	; 0x5a4 <__vector_8>
  22:	00 00       	nop
  24:	46 c0       	rjmp	.+140    	; 0xb2 <__bad_interrupt>
  26:	00 00       	nop
  28:	44 c0       	rjmp	.+136    	; 0xb2 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	42 c0       	rjmp	.+132    	; 0xb2 <__bad_interrupt>
  2e:	00 00       	nop
  30:	40 c0       	rjmp	.+128    	; 0xb2 <__bad_interrupt>
  32:	00 00       	nop
  34:	0b c3       	rjmp	.+1558   	; 0x64c <__vector_13>
  36:	00 00       	nop
  38:	3c c3       	rjmp	.+1656   	; 0x6b2 <__vector_14>
  3a:	00 00       	nop
  3c:	3a c0       	rjmp	.+116    	; 0xb2 <__bad_interrupt>
  3e:	00 00       	nop
  40:	38 c0       	rjmp	.+112    	; 0xb2 <__bad_interrupt>
  42:	00 00       	nop
  44:	36 c0       	rjmp	.+108    	; 0xb2 <__bad_interrupt>
  46:	00 00       	nop
  48:	34 c0       	rjmp	.+104    	; 0xb2 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	32 c0       	rjmp	.+100    	; 0xb2 <__bad_interrupt>
  4e:	00 00       	nop
  50:	ab c3       	rjmp	.+1878   	; 0x7a8 <__vector_20>
  52:	00 00       	nop
  54:	2e c0       	rjmp	.+92     	; 0xb2 <__bad_interrupt>
  56:	00 00       	nop
  58:	d5 c3       	rjmp	.+1962   	; 0x804 <__vector_22>
  5a:	00 00       	nop
  5c:	2a c0       	rjmp	.+84     	; 0xb2 <__bad_interrupt>
  5e:	00 00       	nop
  60:	28 c0       	rjmp	.+80     	; 0xb2 <__bad_interrupt>
  62:	00 00       	nop
  64:	26 c0       	rjmp	.+76     	; 0xb2 <__bad_interrupt>
  66:	00 00       	nop
  68:	24 c0       	rjmp	.+72     	; 0xb2 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	51 c3       	rjmp	.+1698   	; 0x710 <__vector_27>
  6e:	00 00       	nop
  70:	7f c3       	rjmp	.+1790   	; 0x770 <__vector_28>
  72:	00 00       	nop
  74:	1e c0       	rjmp	.+60     	; 0xb2 <__bad_interrupt>
  76:	00 00       	nop
  78:	1c c0       	rjmp	.+56     	; 0xb2 <__bad_interrupt>
	...

0000007c <__ctors_end>:
  7c:	11 24       	eor	r1, r1
  7e:	1f be       	out	0x3f, r1	; 63
  80:	cf ef       	ldi	r28, 0xFF	; 255
  82:	cd bf       	out	0x3d, r28	; 61
  84:	df e3       	ldi	r29, 0x3F	; 63
  86:	de bf       	out	0x3e, r29	; 62

00000088 <__do_copy_data>:
  88:	18 e3       	ldi	r17, 0x38	; 56
  8a:	a0 e0       	ldi	r26, 0x00	; 0
  8c:	b8 e3       	ldi	r27, 0x38	; 56
  8e:	e0 e6       	ldi	r30, 0x60	; 96
  90:	ff e0       	ldi	r31, 0x0F	; 15
  92:	02 c0       	rjmp	.+4      	; 0x98 <__do_copy_data+0x10>
  94:	05 90       	lpm	r0, Z+
  96:	0d 92       	st	X+, r0
  98:	aa 31       	cpi	r26, 0x1A	; 26
  9a:	b1 07       	cpc	r27, r17
  9c:	d9 f7       	brne	.-10     	; 0x94 <__do_copy_data+0xc>

0000009e <__do_clear_bss>:
  9e:	28 e3       	ldi	r18, 0x38	; 56
  a0:	aa e1       	ldi	r26, 0x1A	; 26
  a2:	b8 e3       	ldi	r27, 0x38	; 56
  a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
  a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
  a8:	a9 3b       	cpi	r26, 0xB9	; 185
  aa:	b2 07       	cpc	r27, r18
  ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>
  ae:	11 d6       	rcall	.+3106   	; 0xcd2 <main>
  b0:	35 c7       	rjmp	.+3690   	; 0xf1c <_exit>

000000b2 <__bad_interrupt>:
  b2:	a6 cf       	rjmp	.-180    	; 0x0 <__vectors>

000000b4 <I2C_init>:
// the Atmel device documentation mentions a special command for repeated start TWI_MCMD_REPSTART_gc,
// but this is not used in Atmel's demo code, so we don't use it either

void I2C_rep_start(uint8_t shifted_addr)						    // send repeated start, device_addr + LSB set if READ
{
	TWI0.MADDR = shifted_addr;	
  b4:	81 e0       	ldi	r24, 0x01	; 1
  b6:	80 93 22 04 	sts	0x0422, r24	; 0x800422 <__TEXT_REGION_LENGTH__+0x700422>
  ba:	e6 e2       	ldi	r30, 0x26	; 38
  bc:	f4 e0       	ldi	r31, 0x04	; 4
  be:	80 83       	st	Z, r24
  c0:	10 92 30 04 	sts	0x0430, r1	; 0x800430 <__TEXT_REGION_LENGTH__+0x700430>
  c4:	a1 e2       	ldi	r26, 0x21	; 33
  c6:	b4 e0       	ldi	r27, 0x04	; 4
  c8:	92 e0       	ldi	r25, 0x02	; 2
  ca:	9c 93       	st	X, r25
  cc:	90 83       	st	Z, r25
  ce:	10 92 31 04 	sts	0x0431, r1	; 0x800431 <__TEXT_REGION_LENGTH__+0x700431>
  d2:	e0 e1       	ldi	r30, 0x10	; 16
  d4:	f8 e0       	ldi	r31, 0x08	; 8
  d6:	9d e2       	ldi	r25, 0x2D	; 45
  d8:	96 83       	std	Z+6, r25	; 0x06
  da:	98 e0       	ldi	r25, 0x08	; 8
  dc:	94 83       	std	Z+4, r25	; 0x04
  de:	83 83       	std	Z+3, r24	; 0x03
  e0:	8c 93       	st	X, r24
  e2:	85 81       	ldd	r24, Z+5	; 0x05
  e4:	81 60       	ori	r24, 0x01	; 1
  e6:	85 83       	std	Z+5, r24	; 0x05
  e8:	85 81       	ldd	r24, Z+5	; 0x05
  ea:	84 6c       	ori	r24, 0xC4	; 196
  ec:	85 83       	std	Z+5, r24	; 0x05
  ee:	08 95       	ret

000000f0 <I2C_recover>:
  f0:	e0 e1       	ldi	r30, 0x10	; 16
  f2:	f8 e0       	ldi	r31, 0x08	; 8
  f4:	84 81       	ldd	r24, Z+4	; 0x04
  f6:	88 60       	ori	r24, 0x08	; 8
  f8:	84 83       	std	Z+4, r24	; 0x04
  fa:	13 82       	std	Z+3, r1	; 0x03
  fc:	82 e0       	ldi	r24, 0x02	; 2
  fe:	80 93 22 04 	sts	0x0422, r24	; 0x800422 <__TEXT_REGION_LENGTH__+0x700422>
 102:	89 e0       	ldi	r24, 0x09	; 9
 104:	a1 e2       	ldi	r26, 0x21	; 33
 106:	b4 e0       	ldi	r27, 0x04	; 4
 108:	91 e0       	ldi	r25, 0x01	; 1
 10a:	e2 e2       	ldi	r30, 0x22	; 34
 10c:	f4 e0       	ldi	r31, 0x04	; 4
 10e:	9c 93       	st	X, r25
 110:	20 e1       	ldi	r18, 0x10	; 16
 112:	2a 95       	dec	r18
 114:	f1 f7       	brne	.-4      	; 0x112 <I2C_recover+0x22>
 116:	00 c0       	rjmp	.+0      	; 0x118 <I2C_recover+0x28>
 118:	90 83       	st	Z, r25
 11a:	20 e1       	ldi	r18, 0x10	; 16
 11c:	2a 95       	dec	r18
 11e:	f1 f7       	brne	.-4      	; 0x11c <I2C_recover+0x2c>
 120:	00 c0       	rjmp	.+0      	; 0x122 <I2C_recover+0x32>
 122:	81 50       	subi	r24, 0x01	; 1
 124:	a1 f7       	brne	.-24     	; 0x10e <I2C_recover+0x1e>
 126:	e0 e1       	ldi	r30, 0x10	; 16
 128:	f8 e0       	ldi	r31, 0x08	; 8
 12a:	28 e0       	ldi	r18, 0x08	; 8
 12c:	24 83       	std	Z+4, r18	; 0x04
 12e:	81 e0       	ldi	r24, 0x01	; 1
 130:	83 83       	std	Z+3, r24	; 0x03
 132:	a1 e2       	ldi	r26, 0x21	; 33
 134:	b4 e0       	ldi	r27, 0x04	; 4
 136:	92 e0       	ldi	r25, 0x02	; 2
 138:	9c 93       	st	X, r25
 13a:	95 81       	ldd	r25, Z+5	; 0x05
 13c:	91 60       	ori	r25, 0x01	; 1
 13e:	95 83       	std	Z+5, r25	; 0x05
 140:	95 81       	ldd	r25, Z+5	; 0x05
 142:	94 6c       	ori	r25, 0xC4	; 196
 144:	95 83       	std	Z+5, r25	; 0x05
 146:	24 83       	std	Z+4, r18	; 0x04
 148:	83 83       	std	Z+3, r24	; 0x03
 14a:	8c 93       	st	X, r24
 14c:	85 81       	ldd	r24, Z+5	; 0x05
 14e:	81 60       	ori	r24, 0x01	; 1
 150:	85 83       	std	Z+5, r24	; 0x05
 152:	85 81       	ldd	r24, Z+5	; 0x05
 154:	84 6c       	ori	r24, 0xC4	; 196
 156:	85 83       	std	Z+5, r24	; 0x05
 158:	08 95       	ret

0000015a <I2C_start>:
 15a:	28 2f       	mov	r18, r24
 15c:	e0 e1       	ldi	r30, 0x10	; 16
 15e:	f8 e0       	ldi	r31, 0x08	; 8
 160:	95 81       	ldd	r25, Z+5	; 0x05
 162:	90 6c       	ori	r25, 0xC0	; 192
 164:	95 83       	std	Z+5, r25	; 0x05
 166:	95 81       	ldd	r25, Z+5	; 0x05
 168:	89 2f       	mov	r24, r25
 16a:	84 70       	andi	r24, 0x04	; 4
 16c:	92 fd       	sbrc	r25, 2
 16e:	03 c0       	rjmp	.+6      	; 0x176 <I2C_start+0x1c>
 170:	20 93 17 08 	sts	0x0817, r18	; 0x800817 <__TEXT_REGION_LENGTH__+0x700817>
 174:	08 95       	ret
 176:	84 e0       	ldi	r24, 0x04	; 4
 178:	08 95       	ret

0000017a <I2C_wait_ACK>:
 17a:	8c e0       	ldi	r24, 0x0C	; 12
 17c:	80 93 20 38 	sts	0x3820, r24	; 0x803820 <timeout_I2C>
 180:	e0 e1       	ldi	r30, 0x10	; 16
 182:	f8 e0       	ldi	r31, 0x08	; 8
 184:	04 c0       	rjmp	.+8      	; 0x18e <I2C_wait_ACK+0x14>
 186:	80 91 20 38 	lds	r24, 0x3820	; 0x803820 <timeout_I2C>
 18a:	88 23       	and	r24, r24
 18c:	b9 f0       	breq	.+46     	; 0x1bc <I2C_wait_ACK+0x42>
 18e:	85 81       	ldd	r24, Z+5	; 0x05
 190:	88 23       	and	r24, r24
 192:	1c f0       	brlt	.+6      	; 0x19a <I2C_wait_ACK+0x20>
 194:	85 81       	ldd	r24, Z+5	; 0x05
 196:	86 ff       	sbrs	r24, 6
 198:	f6 cf       	rjmp	.-20     	; 0x186 <I2C_wait_ACK+0xc>
 19a:	e0 e1       	ldi	r30, 0x10	; 16
 19c:	f8 e0       	ldi	r31, 0x08	; 8
 19e:	85 81       	ldd	r24, Z+5	; 0x05
 1a0:	80 6c       	ori	r24, 0xC0	; 192
 1a2:	85 83       	std	Z+5, r24	; 0x05
 1a4:	85 81       	ldd	r24, Z+5	; 0x05
 1a6:	82 fd       	sbrc	r24, 2
 1a8:	0b c0       	rjmp	.+22     	; 0x1c0 <I2C_wait_ACK+0x46>
 1aa:	80 91 15 08 	lds	r24, 0x0815	; 0x800815 <__TEXT_REGION_LENGTH__+0x700815>
 1ae:	83 fd       	sbrc	r24, 3
 1b0:	09 c0       	rjmp	.+18     	; 0x1c4 <I2C_wait_ACK+0x4a>
 1b2:	80 91 15 08 	lds	r24, 0x0815	; 0x800815 <__TEXT_REGION_LENGTH__+0x700815>
 1b6:	82 95       	swap	r24
 1b8:	81 70       	andi	r24, 0x01	; 1
 1ba:	08 95       	ret
 1bc:	8f ef       	ldi	r24, 0xFF	; 255
 1be:	08 95       	ret
 1c0:	84 e0       	ldi	r24, 0x04	; 4
 1c2:	08 95       	ret
 1c4:	82 e0       	ldi	r24, 0x02	; 2
 1c6:	08 95       	ret

000001c8 <I2C_read>:
}

uint8_t	I2C_read(uint8_t *data, uint8_t ack_flag)					// read data, ack_flag 0: send ACK, 1: send NACK, returns status
{
 1c8:	dc 01       	movw	r26, r24
	timeout_I2C = READ_TIMEOUT;										// reset timeout counter, will be decremented by LED matrix interrupt
 1ca:	9c e0       	ldi	r25, 0x0C	; 12
 1cc:	90 93 20 38 	sts	0x3820, r25	; 0x803820 <timeout_I2C>
	if ((TWI0.MSTATUS & TWI_BUSSTATE_gm) == TWI_BUSSTATE_OWNER_gc)	// if master controls bus
 1d0:	90 91 15 08 	lds	r25, 0x0815	; 0x800815 <__TEXT_REGION_LENGTH__+0x700815>
 1d4:	89 2f       	mov	r24, r25
 1d6:	83 70       	andi	r24, 0x03	; 3
 1d8:	82 30       	cpi	r24, 0x02	; 2
 1da:	39 f0       	breq	.+14     	; 0x1ea <I2C_read+0x22>
		else		TWI0.MCTRLB |= TWI_ACKACT_NACK_gc;				// setup NACK (last byte read)
		*data = TWI0.MDATA;
		if (ack_flag == 0) TWI0.MCTRLB |= TWI_MCMD_RECVTRANS_gc;	// send ACK, more bytes to follow					
		return 0;
	}
	else return 8;													// master does not control bus
 1dc:	88 e0       	ldi	r24, 0x08	; 8
 1de:	08 95       	ret
	timeout_I2C = READ_TIMEOUT;										// reset timeout counter, will be decremented by LED matrix interrupt
	if ((TWI0.MSTATUS & TWI_BUSSTATE_gm) == TWI_BUSSTATE_OWNER_gc)	// if master controls bus
	{		
		while (!(TWI0.MSTATUS & TWI_RIF_bm))						// wait for RIF set (data byte received)
		{
			if (!(timeout_I2C)) return 0xff;			            // return timeout error
 1e0:	90 91 20 38 	lds	r25, 0x3820	; 0x803820 <timeout_I2C>
 1e4:	91 11       	cpse	r25, r1
 1e6:	03 c0       	rjmp	.+6      	; 0x1ee <I2C_read+0x26>
 1e8:	2a c0       	rjmp	.+84     	; 0x23e <I2C_read+0x76>
uint8_t	I2C_read(uint8_t *data, uint8_t ack_flag)					// read data, ack_flag 0: send ACK, 1: send NACK, returns status
{
	timeout_I2C = READ_TIMEOUT;										// reset timeout counter, will be decremented by LED matrix interrupt
	if ((TWI0.MSTATUS & TWI_BUSSTATE_gm) == TWI_BUSSTATE_OWNER_gc)	// if master controls bus
	{		
		while (!(TWI0.MSTATUS & TWI_RIF_bm))						// wait for RIF set (data byte received)
 1ea:	e0 e1       	ldi	r30, 0x10	; 16
 1ec:	f8 e0       	ldi	r31, 0x08	; 8
 1ee:	95 81       	ldd	r25, Z+5	; 0x05
 1f0:	99 23       	and	r25, r25
 1f2:	b4 f7       	brge	.-20     	; 0x1e0 <I2C_read+0x18>
		{
			if (!(timeout_I2C)) return 0xff;			            // return timeout error
		}
		TWI0.MSTATUS |= (TWI_RIF_bm | TWI_WIF_bm);					// clear Read and Write interrupt flags	
 1f4:	e0 e1       	ldi	r30, 0x10	; 16
 1f6:	f8 e0       	ldi	r31, 0x08	; 8
 1f8:	95 81       	ldd	r25, Z+5	; 0x05
 1fa:	90 6c       	ori	r25, 0xC0	; 192
 1fc:	95 83       	std	Z+5, r25	; 0x05
		if (TWI0.MSTATUS & TWI_BUSERR_bm) return 4;					// Bus Error, abort
 1fe:	95 81       	ldd	r25, Z+5	; 0x05
 200:	92 fd       	sbrc	r25, 2
 202:	1f c0       	rjmp	.+62     	; 0x242 <I2C_read+0x7a>
		if (TWI0.MSTATUS & TWI_ARBLOST_bm) return 2;				// Arbitration Lost, abort
 204:	90 91 15 08 	lds	r25, 0x0815	; 0x800815 <__TEXT_REGION_LENGTH__+0x700815>
 208:	93 fd       	sbrc	r25, 3
 20a:	1e c0       	rjmp	.+60     	; 0x248 <I2C_read+0x80>
		if (TWI0.MSTATUS & TWI_RXACK_bm) return 1;					// Slave replied with NACK, abort				
 20c:	90 91 15 08 	lds	r25, 0x0815	; 0x800815 <__TEXT_REGION_LENGTH__+0x700815>
 210:	89 2f       	mov	r24, r25
 212:	80 71       	andi	r24, 0x10	; 16
 214:	94 fd       	sbrc	r25, 4
 216:	17 c0       	rjmp	.+46     	; 0x246 <I2C_read+0x7e>
		if (ack_flag == 0) TWI0.MCTRLB &= ~(1 << TWI_ACKACT_bp);	// setup ACK
 218:	61 11       	cpse	r22, r1
 21a:	09 c0       	rjmp	.+18     	; 0x22e <I2C_read+0x66>
 21c:	94 81       	ldd	r25, Z+4	; 0x04
 21e:	9b 7f       	andi	r25, 0xFB	; 251
 220:	94 83       	std	Z+4, r25	; 0x04
		else		TWI0.MCTRLB |= TWI_ACKACT_NACK_gc;				// setup NACK (last byte read)
		*data = TWI0.MDATA;
 222:	90 85       	ldd	r25, Z+8	; 0x08
 224:	9c 93       	st	X, r25
		if (ack_flag == 0) TWI0.MCTRLB |= TWI_MCMD_RECVTRANS_gc;	// send ACK, more bytes to follow					
 226:	94 81       	ldd	r25, Z+4	; 0x04
 228:	92 60       	ori	r25, 0x02	; 2
 22a:	94 83       	std	Z+4, r25	; 0x04
 22c:	08 95       	ret
		TWI0.MSTATUS |= (TWI_RIF_bm | TWI_WIF_bm);					// clear Read and Write interrupt flags	
		if (TWI0.MSTATUS & TWI_BUSERR_bm) return 4;					// Bus Error, abort
		if (TWI0.MSTATUS & TWI_ARBLOST_bm) return 2;				// Arbitration Lost, abort
		if (TWI0.MSTATUS & TWI_RXACK_bm) return 1;					// Slave replied with NACK, abort				
		if (ack_flag == 0) TWI0.MCTRLB &= ~(1 << TWI_ACKACT_bp);	// setup ACK
		else		TWI0.MCTRLB |= TWI_ACKACT_NACK_gc;				// setup NACK (last byte read)
 22e:	e0 e1       	ldi	r30, 0x10	; 16
 230:	f8 e0       	ldi	r31, 0x08	; 8
 232:	94 81       	ldd	r25, Z+4	; 0x04
 234:	94 60       	ori	r25, 0x04	; 4
 236:	94 83       	std	Z+4, r25	; 0x04
		*data = TWI0.MDATA;
 238:	90 85       	ldd	r25, Z+8	; 0x08
 23a:	9c 93       	st	X, r25
 23c:	08 95       	ret
	timeout_I2C = READ_TIMEOUT;										// reset timeout counter, will be decremented by LED matrix interrupt
	if ((TWI0.MSTATUS & TWI_BUSSTATE_gm) == TWI_BUSSTATE_OWNER_gc)	// if master controls bus
	{		
		while (!(TWI0.MSTATUS & TWI_RIF_bm))						// wait for RIF set (data byte received)
		{
			if (!(timeout_I2C)) return 0xff;			            // return timeout error
 23e:	8f ef       	ldi	r24, 0xFF	; 255
 240:	08 95       	ret
		}
		TWI0.MSTATUS |= (TWI_RIF_bm | TWI_WIF_bm);					// clear Read and Write interrupt flags	
		if (TWI0.MSTATUS & TWI_BUSERR_bm) return 4;					// Bus Error, abort
 242:	84 e0       	ldi	r24, 0x04	; 4
 244:	08 95       	ret
		if (TWI0.MSTATUS & TWI_ARBLOST_bm) return 2;				// Arbitration Lost, abort
		if (TWI0.MSTATUS & TWI_RXACK_bm) return 1;					// Slave replied with NACK, abort				
 246:	81 e0       	ldi	r24, 0x01	; 1
		*data = TWI0.MDATA;
		if (ack_flag == 0) TWI0.MCTRLB |= TWI_MCMD_RECVTRANS_gc;	// send ACK, more bytes to follow					
		return 0;
	}
	else return 8;													// master does not control bus
}
 248:	08 95       	ret

0000024a <I2C_write>:

uint8_t I2C_write(uint8_t *data)									// write data, return status
{
 24a:	fc 01       	movw	r30, r24
	timeout_I2C = WRITE_TIMEOUT;									// reset timeout counter, will be decremented by LED matrix interrupt
 24c:	9c e0       	ldi	r25, 0x0C	; 12
 24e:	90 93 20 38 	sts	0x3820, r25	; 0x803820 <timeout_I2C>
	if ((TWI0.MSTATUS & TWI_BUSSTATE_gm) == TWI_BUSSTATE_OWNER_gc)	// if master controls bus
 252:	90 91 15 08 	lds	r25, 0x0815	; 0x800815 <__TEXT_REGION_LENGTH__+0x700815>
 256:	93 70       	andi	r25, 0x03	; 3
 258:	92 30       	cpi	r25, 0x02	; 2
 25a:	b1 f4       	brne	.+44     	; 0x288 <I2C_write+0x3e>
	{
		TWI0.MDATA = *data;		
 25c:	80 81       	ld	r24, Z
 25e:	80 93 18 08 	sts	0x0818, r24	; 0x800818 <__TEXT_REGION_LENGTH__+0x700818>
		while (!(TWI0.MSTATUS & TWI_WIF_bm))						// wait until WIF set, status register contains ACK/NACK bit
 262:	e0 e1       	ldi	r30, 0x10	; 16
 264:	f8 e0       	ldi	r31, 0x08	; 8
 266:	04 c0       	rjmp	.+8      	; 0x270 <I2C_write+0x26>
		{
			if (!(timeout_I2C)) return 0xff;			            // return timeout error
 268:	80 91 20 38 	lds	r24, 0x3820	; 0x803820 <timeout_I2C>
 26c:	88 23       	and	r24, r24
 26e:	71 f0       	breq	.+28     	; 0x28c <I2C_write+0x42>
{
	timeout_I2C = WRITE_TIMEOUT;									// reset timeout counter, will be decremented by LED matrix interrupt
	if ((TWI0.MSTATUS & TWI_BUSSTATE_gm) == TWI_BUSSTATE_OWNER_gc)	// if master controls bus
	{
		TWI0.MDATA = *data;		
		while (!(TWI0.MSTATUS & TWI_WIF_bm))						// wait until WIF set, status register contains ACK/NACK bit
 270:	85 81       	ldd	r24, Z+5	; 0x05
 272:	86 ff       	sbrs	r24, 6
 274:	f9 cf       	rjmp	.-14     	; 0x268 <I2C_write+0x1e>
		{
			if (!(timeout_I2C)) return 0xff;			            // return timeout error
		}
		if (TWI0.MSTATUS & TWI_BUSERR_bm) return 4;					// Bus Error, abort
 276:	80 91 15 08 	lds	r24, 0x0815	; 0x800815 <__TEXT_REGION_LENGTH__+0x700815>
 27a:	82 fd       	sbrc	r24, 2
 27c:	09 c0       	rjmp	.+18     	; 0x290 <I2C_write+0x46>
		if (TWI0.MSTATUS & TWI_RXACK_bm) return 1;					// Slave replied with NACK, abort
 27e:	80 91 15 08 	lds	r24, 0x0815	; 0x800815 <__TEXT_REGION_LENGTH__+0x700815>
	if ((TWI0.MSTATUS & TWI_BUSSTATE_gm) == TWI_BUSSTATE_OWNER_gc)	// if master controls bus
	{
		TWI0.MDATA = *data;		
		while (!(TWI0.MSTATUS & TWI_WIF_bm))						// wait until WIF set, status register contains ACK/NACK bit
		{
			if (!(timeout_I2C)) return 0xff;			            // return timeout error
 282:	82 95       	swap	r24
 284:	81 70       	andi	r24, 0x01	; 1
 286:	08 95       	ret
		}
		if (TWI0.MSTATUS & TWI_BUSERR_bm) return 4;					// Bus Error, abort
		if (TWI0.MSTATUS & TWI_RXACK_bm) return 1;					// Slave replied with NACK, abort
		return 0;													// no error	
	}
	else return 8;													// master does not control bus
 288:	88 e0       	ldi	r24, 0x08	; 8
 28a:	08 95       	ret
	if ((TWI0.MSTATUS & TWI_BUSSTATE_gm) == TWI_BUSSTATE_OWNER_gc)	// if master controls bus
	{
		TWI0.MDATA = *data;		
		while (!(TWI0.MSTATUS & TWI_WIF_bm))						// wait until WIF set, status register contains ACK/NACK bit
		{
			if (!(timeout_I2C)) return 0xff;			            // return timeout error
 28c:	8f ef       	ldi	r24, 0xFF	; 255
 28e:	08 95       	ret
		}
		if (TWI0.MSTATUS & TWI_BUSERR_bm) return 4;					// Bus Error, abort
 290:	84 e0       	ldi	r24, 0x04	; 4
		if (TWI0.MSTATUS & TWI_RXACK_bm) return 1;					// Slave replied with NACK, abort
		return 0;													// no error	
	}
	else return 8;													// master does not control bus
}
 292:	08 95       	ret

00000294 <I2C_stop>:

void I2C_stop()
{
	TWI0.MCTRLB |= TWI_MCMD_STOP_gc;
 294:	e0 e1       	ldi	r30, 0x10	; 16
 296:	f8 e0       	ldi	r31, 0x08	; 8
 298:	84 81       	ldd	r24, Z+4	; 0x04
 29a:	83 60       	ori	r24, 0x03	; 3
 29c:	84 83       	std	Z+4, r24	; 0x04
 29e:	08 95       	ret

000002a0 <I2C_read_bytes>:
// addr_ptr		address of first array element to transfer
// slave reg	starting slave register
// num_bytes	number of bytes to transfer

uint8_t	I2C_read_bytes(uint8_t slave_addr, uint8_t *reg_ptr, uint8_t reg_len, uint8_t *dat_ptr, uint8_t dat_len)
{
 2a0:	cf 92       	push	r12
 2a2:	df 92       	push	r13
 2a4:	ef 92       	push	r14
 2a6:	ff 92       	push	r15
 2a8:	0f 93       	push	r16
 2aa:	1f 93       	push	r17
 2ac:	cf 93       	push	r28
 2ae:	df 93       	push	r29
 2b0:	eb 01       	movw	r28, r22
 2b2:	c4 2e       	mov	r12, r20
 2b4:	79 01       	movw	r14, r18
	uint8_t status;
	if (dat_len > MAX_LEN) dat_len = MAX_LEN;
	status = I2C_start(slave_addr << 1);							// slave write address, LSB 0
 2b6:	18 2f       	mov	r17, r24
 2b8:	11 0f       	add	r17, r17
 2ba:	81 2f       	mov	r24, r17
 2bc:	4e df       	rcall	.-356    	; 0x15a <I2C_start>
	if (status != 0) goto error;
 2be:	81 11       	cpse	r24, r1
	status = I2C_wait_ACK();										// wait for slave ACK
 2c0:	3c c0       	rjmp	.+120    	; 0x33a <I2C_read_bytes+0x9a>
 2c2:	5b df       	rcall	.-330    	; 0x17a <I2C_wait_ACK>
	if (status == 1) {
 2c4:	81 30       	cpi	r24, 0x01	; 1
		I2C_stop();													// NACK, abort
 2c6:	19 f4       	brne	.+6      	; 0x2ce <I2C_read_bytes+0x2e>
 2c8:	e5 df       	rcall	.-54     	; 0x294 <I2C_stop>
		return 1;
 2ca:	81 e0       	ldi	r24, 0x01	; 1
 2cc:	38 c0       	rjmp	.+112    	; 0x33e <I2C_read_bytes+0x9e>
	}
	if (status != 0) goto error;
 2ce:	81 11       	cpse	r24, r1
 2d0:	34 c0       	rjmp	.+104    	; 0x33a <I2C_read_bytes+0x9a>
    while(reg_len > 0){
 2d2:	cc 20       	and	r12, r12
 2d4:	79 f0       	breq	.+30     	; 0x2f4 <I2C_read_bytes+0x54>
 2d6:	ca 94       	dec	r12
 2d8:	d1 2c       	mov	r13, r1
 2da:	8f ef       	ldi	r24, 0xFF	; 255
 2dc:	c8 1a       	sub	r12, r24
 2de:	d8 0a       	sbc	r13, r24
 2e0:	cc 0e       	add	r12, r28
	    status = I2C_write(reg_ptr);    							// send slave start register
 2e2:	dd 1e       	adc	r13, r29
 2e4:	ce 01       	movw	r24, r28
 2e6:	b1 df       	rcall	.-158    	; 0x24a <I2C_write>
	    if (status != 0) goto error;
 2e8:	81 11       	cpse	r24, r1
 2ea:	27 c0       	rjmp	.+78     	; 0x33a <I2C_read_bytes+0x9a>
        ++reg_ptr;
 2ec:	21 96       	adiw	r28, 0x01	; 1
	if (status == 1) {
		I2C_stop();													// NACK, abort
		return 1;
	}
	if (status != 0) goto error;
    while(reg_len > 0){
 2ee:	cc 16       	cp	r12, r28
 2f0:	dd 06       	cpc	r13, r29
 2f2:	c1 f7       	brne	.-16     	; 0x2e4 <I2C_read_bytes+0x44>
 2f4:	01 34       	cpi	r16, 0x41	; 65
 2f6:	08 f0       	brcs	.+2      	; 0x2fa <I2C_read_bytes+0x5a>
 2f8:	00 e4       	ldi	r16, 0x40	; 64
	    status = I2C_write(reg_ptr);    							// send slave start register
	    if (status != 0) goto error;
        ++reg_ptr;
        --reg_len;
    }
	I2C_rep_start((slave_addr << 1) + 1);							// slave read address, LSB 1
 2fa:	1f 5f       	subi	r17, 0xFF	; 255
// the Atmel device documentation mentions a special command for repeated start TWI_MCMD_REPSTART_gc,
// but this is not used in Atmel's demo code, so we don't use it either

void I2C_rep_start(uint8_t shifted_addr)						    // send repeated start, device_addr + LSB set if READ
{
	TWI0.MADDR = shifted_addr;	
 2fc:	10 93 17 08 	sts	0x0817, r17	; 0x800817 <__TEXT_REGION_LENGTH__+0x700817>
	    if (status != 0) goto error;
        ++reg_ptr;
        --reg_len;
    }
	I2C_rep_start((slave_addr << 1) + 1);							// slave read address, LSB 1
	while (dat_len > 1) {
 300:	02 30       	cpi	r16, 0x02	; 2
 302:	90 f0       	brcs	.+36     	; 0x328 <I2C_read_bytes+0x88>
 304:	02 50       	subi	r16, 0x02	; 2
 306:	c0 2f       	mov	r28, r16
 308:	d0 e0       	ldi	r29, 0x00	; 0
 30a:	21 96       	adiw	r28, 0x01	; 1
 30c:	ce 0d       	add	r28, r14
		status = I2C_read(dat_ptr, 0);								// first bytes, send ACK
 30e:	df 1d       	adc	r29, r15
 310:	60 e0       	ldi	r22, 0x00	; 0
 312:	c7 01       	movw	r24, r14
 314:	59 df       	rcall	.-334    	; 0x1c8 <I2C_read>
		if (status != 0) goto error;
 316:	81 11       	cpse	r24, r1
 318:	10 c0       	rjmp	.+32     	; 0x33a <I2C_read_bytes+0x9a>
		++dat_ptr;
 31a:	8f ef       	ldi	r24, 0xFF	; 255
 31c:	e8 1a       	sub	r14, r24
 31e:	f8 0a       	sbc	r15, r24
	    if (status != 0) goto error;
        ++reg_ptr;
        --reg_len;
    }
	I2C_rep_start((slave_addr << 1) + 1);							// slave read address, LSB 1
	while (dat_len > 1) {
 320:	ec 16       	cp	r14, r28
 322:	fd 06       	cpc	r15, r29
 324:	a9 f7       	brne	.-22     	; 0x310 <I2C_read_bytes+0x70>
 326:	01 c0       	rjmp	.+2      	; 0x32a <I2C_read_bytes+0x8a>
		status = I2C_read(dat_ptr, 0);								// first bytes, send ACK
		if (status != 0) goto error;
		++dat_ptr;
		--dat_len;
	}
	status = I2C_read(dat_ptr, 1);									// single or last byte, send NACK
 328:	e7 01       	movw	r28, r14
 32a:	61 e0       	ldi	r22, 0x01	; 1
 32c:	ce 01       	movw	r24, r28
	if (status != 0) goto error;
 32e:	4c df       	rcall	.-360    	; 0x1c8 <I2C_read>
 330:	81 11       	cpse	r24, r1
	I2C_stop();
 332:	03 c0       	rjmp	.+6      	; 0x33a <I2C_read_bytes+0x9a>
 334:	af df       	rcall	.-162    	; 0x294 <I2C_stop>
	return 0;
 336:	80 e0       	ldi	r24, 0x00	; 0
 338:	02 c0       	rjmp	.+4      	; 0x33e <I2C_read_bytes+0x9e>
	
error:
	I2C_recover();													// clock out possibly stuck slave, reset master
 33a:	da de       	rcall	.-588    	; 0xf0 <I2C_recover>
 33c:	8f ef       	ldi	r24, 0xFF	; 255
	return 0xff;													// flag error
 33e:	df 91       	pop	r29
}
 340:	cf 91       	pop	r28
 342:	1f 91       	pop	r17
 344:	0f 91       	pop	r16
 346:	ff 90       	pop	r15
 348:	ef 90       	pop	r14
 34a:	df 90       	pop	r13
 34c:	cf 90       	pop	r12
 34e:	08 95       	ret

00000350 <I2C_write_bytes>:
 350:	cf 92       	push	r12

uint8_t	I2C_write_bytes(uint8_t slave_addr, uint8_t *reg_ptr, uint8_t reg_len, uint8_t *dat_ptr, uint8_t dat_len)
{
 352:	df 92       	push	r13
 354:	ef 92       	push	r14
 356:	ff 92       	push	r15
 358:	0f 93       	push	r16
 35a:	cf 93       	push	r28
 35c:	df 93       	push	r29
 35e:	eb 01       	movw	r28, r22
 360:	e4 2e       	mov	r14, r20
 362:	69 01       	movw	r12, r18
	uint8_t status;
	if (dat_len > MAX_LEN) dat_len = MAX_LEN;
	status = I2C_start(slave_addr << 1);							// slave write address, LSB 0
 364:	88 0f       	add	r24, r24
 366:	f9 de       	rcall	.-526    	; 0x15a <I2C_start>
	if (status != 0) goto error;
 368:	81 11       	cpse	r24, r1
	status = I2C_wait_ACK();										// wait for Slave ACK
 36a:	27 c0       	rjmp	.+78     	; 0x3ba <I2C_write_bytes+0x6a>
 36c:	06 df       	rcall	.-500    	; 0x17a <I2C_wait_ACK>
	if (status == 1) {
 36e:	81 30       	cpi	r24, 0x01	; 1
		I2C_stop();													// NACK, abort	
 370:	19 f4       	brne	.+6      	; 0x378 <I2C_write_bytes+0x28>
 372:	90 df       	rcall	.-224    	; 0x294 <I2C_stop>
		return 1;													
 374:	81 e0       	ldi	r24, 0x01	; 1
 376:	30 c0       	rjmp	.+96     	; 0x3d8 <I2C_write_bytes+0x88>
	}	 										
	if (status != 0) goto error;
 378:	81 11       	cpse	r24, r1
 37a:	1f c0       	rjmp	.+62     	; 0x3ba <I2C_write_bytes+0x6a>
	while(reg_len > 0){
 37c:	ee 20       	and	r14, r14
 37e:	01 f1       	breq	.+64     	; 0x3c0 <I2C_write_bytes+0x70>
 380:	ea 94       	dec	r14
 382:	f1 2c       	mov	r15, r1
 384:	8f ef       	ldi	r24, 0xFF	; 255
 386:	e8 1a       	sub	r14, r24
 388:	f8 0a       	sbc	r15, r24
 38a:	ec 0e       	add	r14, r28
    	status = I2C_write(reg_ptr);    							// send slave start register
 38c:	fd 1e       	adc	r15, r29
 38e:	ce 01       	movw	r24, r28
 390:	5c df       	rcall	.-328    	; 0x24a <I2C_write>
    	if (status != 0) goto error;
 392:	81 11       	cpse	r24, r1
 394:	12 c0       	rjmp	.+36     	; 0x3ba <I2C_write_bytes+0x6a>
    	++reg_ptr;
 396:	21 96       	adiw	r28, 0x01	; 1
	if (status == 1) {
		I2C_stop();													// NACK, abort	
		return 1;													
	}	 										
	if (status != 0) goto error;
	while(reg_len > 0){
 398:	ce 15       	cp	r28, r14
 39a:	df 05       	cpc	r29, r15
 39c:	c1 f7       	brne	.-16     	; 0x38e <I2C_write_bytes+0x3e>
    	++reg_ptr;
    	--reg_len;
	}
	if (status != 0) goto error;
	while (dat_len > 0) {											// write bytes
		status = I2C_write(dat_ptr);
 39e:	10 c0       	rjmp	.+32     	; 0x3c0 <I2C_write_bytes+0x70>
 3a0:	c6 01       	movw	r24, r12
 3a2:	53 df       	rcall	.-346    	; 0x24a <I2C_write>
		if (status != 0) goto error;
 3a4:	81 11       	cpse	r24, r1
 3a6:	09 c0       	rjmp	.+18     	; 0x3ba <I2C_write_bytes+0x6a>
		++dat_ptr;
 3a8:	8f ef       	ldi	r24, 0xFF	; 255
 3aa:	c8 1a       	sub	r12, r24
    	if (status != 0) goto error;
    	++reg_ptr;
    	--reg_len;
	}
	if (status != 0) goto error;
	while (dat_len > 0) {											// write bytes
 3ac:	d8 0a       	sbc	r13, r24
 3ae:	cc 16       	cp	r12, r28
		status = I2C_write(dat_ptr);
		if (status != 0) goto error;
		++dat_ptr;
		--dat_len;		
	}
	I2C_stop();
 3b0:	dd 06       	cpc	r13, r29
 3b2:	b1 f7       	brne	.-20     	; 0x3a0 <I2C_write_bytes+0x50>
	return 0;
 3b4:	6f df       	rcall	.-290    	; 0x294 <I2C_stop>
 3b6:	80 e0       	ldi	r24, 0x00	; 0

error:
	I2C_recover();
 3b8:	0f c0       	rjmp	.+30     	; 0x3d8 <I2C_write_bytes+0x88>
 3ba:	9a de       	rcall	.-716    	; 0xf0 <I2C_recover>
	return 0xff;
 3bc:	8f ef       	ldi	r24, 0xFF	; 255
 3be:	0c c0       	rjmp	.+24     	; 0x3d8 <I2C_write_bytes+0x88>
 3c0:	01 34       	cpi	r16, 0x41	; 65
 3c2:	08 f0       	brcs	.+2      	; 0x3c6 <I2C_write_bytes+0x76>
 3c4:	00 e4       	ldi	r16, 0x40	; 64
    	if (status != 0) goto error;
    	++reg_ptr;
    	--reg_len;
	}
	if (status != 0) goto error;
	while (dat_len > 0) {											// write bytes
 3c6:	00 23       	and	r16, r16
 3c8:	a9 f3       	breq	.-22     	; 0x3b4 <I2C_write_bytes+0x64>
 3ca:	01 50       	subi	r16, 0x01	; 1
 3cc:	c0 2f       	mov	r28, r16
 3ce:	d0 e0       	ldi	r29, 0x00	; 0
 3d0:	21 96       	adiw	r28, 0x01	; 1
 3d2:	cc 0d       	add	r28, r12
 3d4:	dd 1d       	adc	r29, r13
 3d6:	e4 cf       	rjmp	.-56     	; 0x3a0 <I2C_write_bytes+0x50>
	return 0;

error:
	I2C_recover();
	return 0xff;
 3d8:	df 91       	pop	r29
 3da:	cf 91       	pop	r28
 3dc:	0f 91       	pop	r16
 3de:	ff 90       	pop	r15
 3e0:	ef 90       	pop	r14
 3e2:	df 90       	pop	r13
 3e4:	cf 90       	pop	r12
 3e6:	08 95       	ret

000003e8 <setup>:
#include <resources.h>
#include <I2C.h>                //Fixed a semi-crappy lib found on internet, replace with interrupt driven one? If so, check hardware errata pdf!

volatile uint16_t tmp16bit;     

void setup(){
 3e8:	cf 93       	push	r28
 3ea:	df 93       	push	r29
    cli();
 3ec:	f8 94       	cli

    //Set up clock at 10MHz
    CCP = CCP_IOREG_gc;
 3ee:	88 ed       	ldi	r24, 0xD8	; 216
 3f0:	84 bf       	out	0x34, r24	; 52
    CLKCTRL_MCLKCTRLB = 0x01;
 3f2:	c1 e0       	ldi	r28, 0x01	; 1
 3f4:	c0 93 61 00 	sts	0x0061, r28	; 0x800061 <__TEXT_REGION_LENGTH__+0x700061>

    //Set I/O direction registers
    PORTA_DIR = 0b01001010;
 3f8:	8a e4       	ldi	r24, 0x4A	; 74
 3fa:	80 93 00 04 	sts	0x0400, r24	; 0x800400 <__TEXT_REGION_LENGTH__+0x700400>
    PORTB_DIR = 0b01111100;
 3fe:	8c e7       	ldi	r24, 0x7C	; 124
 400:	80 93 20 04 	sts	0x0420, r24	; 0x800420 <__TEXT_REGION_LENGTH__+0x700420>
    PORTC_DIR = 0b00111111;
 404:	8f e3       	ldi	r24, 0x3F	; 63
 406:	80 93 40 04 	sts	0x0440, r24	; 0x800440 <__TEXT_REGION_LENGTH__+0x700440>
     
    //UART (Alternative pins PA1=TxD, PA2=RxD, baudrate 9600, 8n1, RX and Buffer empty interrupts on)
    PORTMUX_CTRLB = 0x01;
 40a:	c0 93 01 02 	sts	0x0201, r28	; 0x800201 <__TEXT_REGION_LENGTH__+0x700201>
    PORTA_OUTSET = 0x02;
 40e:	d2 e0       	ldi	r29, 0x02	; 2
 410:	d0 93 05 04 	sts	0x0405, r29	; 0x800405 <__TEXT_REGION_LENGTH__+0x700405>
    USART0_BAUD = (uint16_t)USART0_BAUD_RATE(115200);
 414:	2b e5       	ldi	r18, 0x5B	; 91
 416:	31 e0       	ldi	r19, 0x01	; 1
 418:	20 93 08 08 	sts	0x0808, r18	; 0x800808 <__TEXT_REGION_LENGTH__+0x700808>
 41c:	30 93 09 08 	sts	0x0809, r19	; 0x800809 <__TEXT_REGION_LENGTH__+0x700809>
    USART0_CTRLA = 0xA0; //Interrupts on
 420:	90 ea       	ldi	r25, 0xA0	; 160
 422:	90 93 05 08 	sts	0x0805, r25	; 0x800805 <__TEXT_REGION_LENGTH__+0x700805>
    USART0_CTRLB = 0xC0; //RX and TX on
 426:	90 ec       	ldi	r25, 0xC0	; 192
 428:	90 93 06 08 	sts	0x0806, r25	; 0x800806 <__TEXT_REGION_LENGTH__+0x700806>
    USART0_CTRLC = 0x03; //8 bits data, no parity, 1 stop bit
 42c:	93 e0       	ldi	r25, 0x03	; 3
 42e:	90 93 07 08 	sts	0x0807, r25	; 0x800807 <__TEXT_REGION_LENGTH__+0x700807>
     
    //GPIO registers 0..3 can be used for global variables used in ISR routines (ASM capability: IN, OUT, SBI, CBI, SBIS, SBIC)
    L_COL = 0;     //Used in LED array to hold currently driven column value
 432:	1c ba       	out	0x1c, r1	; 28
    RXCNT = 0;     //Used as UART receive counter
 434:	1d ba       	out	0x1d, r1	; 29
    AUPOS = 0;     //Used as audio input/output buffer counter
 436:	1e ba       	out	0x1e, r1	; 30
    GPIOR3 = 0;    //
 438:	1f ba       	out	0x1f, r1	; 31

    //Init TCA (split mode, f_CLK/16, PWM on 6 alternative pins, underflow int enabled, synced and started)
    TCA0_SPLIT_CTRLD = 1;
 43a:	c0 93 03 0a 	sts	0x0A03, r28	; 0x800a03 <__TEXT_REGION_LENGTH__+0x700a03>
    TCA0_SPLIT_CTRLA = (0x4)<<1;
 43e:	e0 e0       	ldi	r30, 0x00	; 0
 440:	fa e0       	ldi	r31, 0x0A	; 10
 442:	98 e0       	ldi	r25, 0x08	; 8
 444:	90 83       	st	Z, r25
    PORTMUX_CTRLC = 0x3F;
 446:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <__TEXT_REGION_LENGTH__+0x700202>
    TCA0_SPLIT_CTRLB = 0x77;
 44a:	87 e7       	ldi	r24, 0x77	; 119
 44c:	80 93 01 0a 	sts	0x0A01, r24	; 0x800a01 <__TEXT_REGION_LENGTH__+0x700a01>
    TCA0_SPLIT_INTCTRL = 0x1;
 450:	c0 93 0a 0a 	sts	0x0A0A, r28	; 0x800a0a <__TEXT_REGION_LENGTH__+0x700a0a>
    TCA0_SPLIT_CTRLESET = ((0x2)<<2)|0x3;
 454:	8b e0       	ldi	r24, 0x0B	; 11
 456:	80 93 05 0a 	sts	0x0A05, r24	; 0x800a05 <__TEXT_REGION_LENGTH__+0x700a05>
    TCA0_SPLIT_CTRLA |= 1;
 45a:	80 81       	ld	r24, Z
 45c:	81 60       	ori	r24, 0x01	; 1
 45e:	80 83       	st	Z, r24
     
    //Init TCB0 (compare value sets serial Tx pause between characters, uses TCA0 prescaler, enabled, interrupt disabled)
    TCB0_CTRLA = ((0x02)<<1)|0x01;
 460:	85 e0       	ldi	r24, 0x05	; 5
 462:	80 93 40 0a 	sts	0x0A40, r24	; 0x800a40 <__TEXT_REGION_LENGTH__+0x700a40>
    TCB0_CTRLB = 0;
 466:	10 92 41 0a 	sts	0x0A41, r1	; 0x800a41 <__TEXT_REGION_LENGTH__+0x700a41>
    TCB0_CCMP = 0x01FF;
 46a:	8f ef       	ldi	r24, 0xFF	; 255
 46c:	91 e0       	ldi	r25, 0x01	; 1
 46e:	80 93 4c 0a 	sts	0x0A4C, r24	; 0x800a4c <__TEXT_REGION_LENGTH__+0x700a4c>
 472:	90 93 4d 0a 	sts	0x0A4D, r25	; 0x800a4d <__TEXT_REGION_LENGTH__+0x700a4d>
    TCB0_INTCTRL = 0x00;     
 476:	10 92 45 0a 	sts	0x0A45, r1	; 0x800a45 <__TEXT_REGION_LENGTH__+0x700a45>
     
    //Init TCB1 (compare value sets audio sample rate (0x038B = 11025sps), enabled, interrupt enabled)
    TCB1_CTRLA = 0x01;
 47a:	c0 93 50 0a 	sts	0x0A50, r28	; 0x800a50 <__TEXT_REGION_LENGTH__+0x700a50>
    TCB1_CTRLB = 0;
 47e:	10 92 51 0a 	sts	0x0A51, r1	; 0x800a51 <__TEXT_REGION_LENGTH__+0x700a51>
    TCB1_CCMP = 0x038B;
 482:	8b e8       	ldi	r24, 0x8B	; 139
 484:	93 e0       	ldi	r25, 0x03	; 3
 486:	80 93 5c 0a 	sts	0x0A5C, r24	; 0x800a5c <__TEXT_REGION_LENGTH__+0x700a5c>
 48a:	90 93 5d 0a 	sts	0x0A5D, r25	; 0x800a5d <__TEXT_REGION_LENGTH__+0x700a5d>
    TCB1_INTCTRL = 0x01;
 48e:	c0 93 55 0a 	sts	0x0A55, r28	; 0x800a55 <__TEXT_REGION_LENGTH__+0x700a55>

    //Init I2C (100kHz)
    I2C_init();
 492:	10 de       	rcall	.-992    	; 0xb4 <I2C_init>

    //VREF (DAC, ADC's)
    VREF_CTRLA   = 0x12;    //0x22 for audio in/out (2.5V), 0x12 for temperature in, audio out (1.1V/2.5V)
 494:	82 e1       	ldi	r24, 0x12	; 18
 496:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
    VREF_CTRLC   = 0x20;    //ADC1 reference at 2.5V
 49a:	80 e2       	ldi	r24, 0x20	; 32
 49c:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    VREF_CTRLB   = 0x01;    //DAC0 ref forced enabled
 4a0:	c0 93 a1 00 	sts	0x00A1, r28	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>

    //Init ADC0 (audio in, also controls DAC output rate, internal temperature?)
    ADC0_CTRLA   = 0x06;    //8 bit resolution, free running
 4a4:	e0 e0       	ldi	r30, 0x00	; 0
 4a6:	f6 e0       	ldi	r31, 0x06	; 6
 4a8:	86 e0       	ldi	r24, 0x06	; 6
 4aa:	80 83       	st	Z, r24
    ADC0_CTRLC   = 0x44;    //Reduced sample capacitor, internal reference, clock/32 => 24038sps
 4ac:	84 e4       	ldi	r24, 0x44	; 68
 4ae:	80 93 02 06 	sts	0x0602, r24	; 0x800602 <__TEXT_REGION_LENGTH__+0x700602>
    ADC0_MUXPOS  = 0x1E;    //Audio in: AIN7 at (0x07), Temperature: Internal sensor at (0x1E)
 4b2:	8e e1       	ldi	r24, 0x1E	; 30
 4b4:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
    ADC0_INTCTRL = 0x01;    //Result ready interrupt enabled
 4b8:	c0 93 0a 06 	sts	0x060A, r28	; 0x80060a <__TEXT_REGION_LENGTH__+0x70060a>
    ADC0_CTRLA  |= 0x01;    //ADC0 enabled
 4bc:	80 81       	ld	r24, Z
 4be:	81 60       	ori	r24, 0x01	; 1
 4c0:	80 83       	st	Z, r24
    ADC0_COMMAND = 0x01;    //Start first conversion, after that it will run periodically.
 4c2:	c0 93 08 06 	sts	0x0608, r28	; 0x800608 <__TEXT_REGION_LENGTH__+0x700608>

    //Init ADC1 (buttons and sensors: CH0=Photo transistor, CH1=Hall, CH4=Buttons)
    ADC1_CTRLA   = 0;
 4c6:	e0 e4       	ldi	r30, 0x40	; 64
 4c8:	f6 e0       	ldi	r31, 0x06	; 6
 4ca:	10 82       	st	Z, r1
    ADC1_CTRLB   = 0x02;    //4 results automatically accumulated
 4cc:	d0 93 41 06 	sts	0x0641, r29	; 0x800641 <__TEXT_REGION_LENGTH__+0x700641>
    ADC1_CTRLC   = 0x52;    //Reduced sample capacitor, VDD as reference, clock/8
 4d0:	82 e5       	ldi	r24, 0x52	; 82
 4d2:	80 93 42 06 	sts	0x0642, r24	; 0x800642 <__TEXT_REGION_LENGTH__+0x700642>
    ADC1_SAMPCTRL= 0x04;    //Extend sampling time with 4 cycles (6 total)
 4d6:	84 e0       	ldi	r24, 0x04	; 4
 4d8:	80 93 45 06 	sts	0x0645, r24	; 0x800645 <__TEXT_REGION_LENGTH__+0x700645>
    ADC1_MUXPOS  = 0x04;    //Start with Buttons, for sensors, activate sensor power first.
 4dc:	80 93 46 06 	sts	0x0646, r24	; 0x800646 <__TEXT_REGION_LENGTH__+0x700646>
    ADC1_INTCTRL = 0x01;    //Result ready interrupt enabled
 4e0:	c0 93 4a 06 	sts	0x064A, r28	; 0x80064a <__TEXT_REGION_LENGTH__+0x70064a>
    ADC1_CTRLA  |= 0x01;    //ADC0 enabled
 4e4:	80 81       	ld	r24, Z
 4e6:	81 60       	ori	r24, 0x01	; 1
 4e8:	80 83       	st	Z, r24
    ADC1_COMMAND = 0x01;    //Start single conversion
 4ea:	c0 93 48 06 	sts	0x0648, r28	; 0x800648 <__TEXT_REGION_LENGTH__+0x700648>

    //Init DAC0
    DAC0_CTRLA = 0x40;     //Enable output buffer (connect to pin)
 4ee:	e0 ea       	ldi	r30, 0xA0	; 160
 4f0:	f6 e0       	ldi	r31, 0x06	; 6
 4f2:	80 e4       	ldi	r24, 0x40	; 64
 4f4:	80 83       	st	Z, r24
    DAC0_DATA = 0x80;      //Data value at half point (about 1.25V)
 4f6:	80 e8       	ldi	r24, 0x80	; 128
 4f8:	80 93 a1 06 	sts	0x06A1, r24	; 0x8006a1 <__TEXT_REGION_LENGTH__+0x7006a1>
    DAC0_CTRLA |= 0x01;    //Enable DAC
 4fc:	80 81       	ld	r24, Z
 4fe:	81 60       	ori	r24, 0x01	; 1
 500:	80 83       	st	Z, r24
     
    //PIT and RTC interrupts
    while(RTC_STATUS & RTC_CTRLABUSY_bm);
 502:	e1 e4       	ldi	r30, 0x41	; 65
 504:	f1 e0       	ldi	r31, 0x01	; 1
 506:	80 81       	ld	r24, Z
 508:	80 fd       	sbrc	r24, 0
 50a:	fd cf       	rjmp	.-6      	; 0x506 <__LOCK_REGION_LENGTH__+0x106>
    RTC_CTRLA          = (0x6)<<3;                         //Prescaler: /64
 50c:	80 e3       	ldi	r24, 0x30	; 48
 50e:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <__TEXT_REGION_LENGTH__+0x700140>
    RTC_CLKSEL         = 0;                                //Clock source: internal 32768Hz clock
 512:	10 92 47 01 	sts	0x0147, r1	; 0x800147 <__TEXT_REGION_LENGTH__+0x700147>
    while(RTC_STATUS & RTC_PERBUSY_bm);
 516:	e1 e4       	ldi	r30, 0x41	; 65
 518:	f1 e0       	ldi	r31, 0x01	; 1
 51a:	80 81       	ld	r24, Z
 51c:	82 fd       	sbrc	r24, 2
 51e:	fd cf       	rjmp	.-6      	; 0x51a <__LOCK_REGION_LENGTH__+0x11a>
    RTC_PER            = 512*60;                           //60 second period (for clocking how long the device has been running?)
 520:	ea e4       	ldi	r30, 0x4A	; 74
 522:	f1 e0       	ldi	r31, 0x01	; 1
 524:	80 e0       	ldi	r24, 0x00	; 0
 526:	98 e7       	ldi	r25, 0x78	; 120
 528:	80 83       	st	Z, r24
 52a:	91 83       	std	Z+1, r25	; 0x01
    tmp16bit = (RTC_CNT + BTN_TMR)%RTC_PER;
 52c:	80 91 48 01 	lds	r24, 0x0148	; 0x800148 <__TEXT_REGION_LENGTH__+0x700148>
 530:	90 91 49 01 	lds	r25, 0x0149	; 0x800149 <__TEXT_REGION_LENGTH__+0x700149>
 534:	60 81       	ld	r22, Z
 536:	71 81       	ldd	r23, Z+1	; 0x01
 538:	82 96       	adiw	r24, 0x22	; 34
 53a:	dc d4       	rcall	.+2488   	; 0xef4 <__udivmodhi4>
 53c:	80 93 96 38 	sts	0x3896, r24	; 0x803896 <tmp16bit>
 540:	90 93 97 38 	sts	0x3897, r25	; 0x803897 <tmp16bit+0x1>
    while(RTC_STATUS & RTC_CMPBUSY_bm);
 544:	e1 e4       	ldi	r30, 0x41	; 65
 546:	f1 e0       	ldi	r31, 0x01	; 1
 548:	80 81       	ld	r24, Z
 54a:	83 fd       	sbrc	r24, 3
 54c:	fd cf       	rjmp	.-6      	; 0x548 <__LOCK_REGION_LENGTH__+0x148>
    RTC_CMP            = tmp16bit;                         //Button timing
 54e:	80 91 96 38 	lds	r24, 0x3896	; 0x803896 <tmp16bit>
 552:	90 91 97 38 	lds	r25, 0x3897	; 0x803897 <tmp16bit+0x1>
 556:	80 93 4c 01 	sts	0x014C, r24	; 0x80014c <__TEXT_REGION_LENGTH__+0x70014c>
 55a:	90 93 4d 01 	sts	0x014D, r25	; 0x80014d <__TEXT_REGION_LENGTH__+0x70014d>
    RTC_INTCTRL        = 0x03;                             //RTC overflow interrupt enabled
 55e:	83 e0       	ldi	r24, 0x03	; 3
 560:	80 93 42 01 	sts	0x0142, r24	; 0x800142 <__TEXT_REGION_LENGTH__+0x700142>
    RTC_PITINTCTRL     = 0x01;                             //PIT interrupt enabled
 564:	81 e0       	ldi	r24, 0x01	; 1
 566:	80 93 52 01 	sts	0x0152, r24	; 0x800152 <__TEXT_REGION_LENGTH__+0x700152>
    RTC_PITCTRLA       = (0x1)<<3;                         //Interrupt fires after 4 RTC clock cycles Rate=(RTCCLK/(PRESC*PERIOD)) 32768/256=128Hz
 56a:	88 e0       	ldi	r24, 0x08	; 8
 56c:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <__TEXT_REGION_LENGTH__+0x700150>
    while(RTC_STATUS & RTC_CTRLABUSY_bm);      
 570:	e1 e4       	ldi	r30, 0x41	; 65
 572:	f1 e0       	ldi	r31, 0x01	; 1
 574:	80 81       	ld	r24, Z
 576:	80 fd       	sbrc	r24, 0
 578:	fd cf       	rjmp	.-6      	; 0x574 <__LOCK_REGION_LENGTH__+0x174>
    RTC_CTRLA          |= 0x01;                            //Enable RTC
 57a:	e0 e4       	ldi	r30, 0x40	; 64
 57c:	f1 e0       	ldi	r31, 0x01	; 1
 57e:	80 81       	ld	r24, Z
 580:	81 60       	ori	r24, 0x01	; 1
 582:	80 83       	st	Z, r24
    RTC_PITCTRLA       |= 0x01;                            //Enable PIT
 584:	e0 e5       	ldi	r30, 0x50	; 80
 586:	f1 e0       	ldi	r31, 0x01	; 1
 588:	80 81       	ld	r24, Z
 58a:	81 60       	ori	r24, 0x01	; 1
 58c:	80 83       	st	Z, r24
     
    //Other inits
    serRx[0] = 0;           // Empty Rx buffer (first char is enough)
 58e:	e1 e2       	ldi	r30, 0x21	; 33
 590:	f8 e3       	ldi	r31, 0x38	; 56
 592:	10 82       	st	Z, r1
    serTxAddr = &serRx[0];  // Point to first address of the Rx buffer
 594:	e0 93 45 38 	sts	0x3845, r30	; 0x803845 <serTxAddr>
 598:	f0 93 46 38 	sts	0x3846, r31	; 0x803846 <serTxAddr+0x1>

    sei();
 59c:	78 94       	sei
}
 59e:	df 91       	pop	r29
 5a0:	cf 91       	pop	r28
 5a2:	08 95       	ret

000005a4 <__vector_8>:

// TCA0 is used for driving the LED matrix at 488Hz (* 5 columns = 2440Hz). The lower 8 bit underflow interrupt is used to load new values and shift between columns.
ISR(TCA0_LUNF_vect){
 5a4:	1f 92       	push	r1
 5a6:	0f 92       	push	r0
 5a8:	0f b6       	in	r0, 0x3f	; 63
 5aa:	0f 92       	push	r0
 5ac:	11 24       	eor	r1, r1
 5ae:	8f 93       	push	r24
 5b0:	9f 93       	push	r25
 5b2:	af 93       	push	r26
 5b4:	bf 93       	push	r27
 5b6:	ef 93       	push	r30
 5b8:	ff 93       	push	r31
    //Turn off all columns
    PORTC_OUTCLR = 0x07;
 5ba:	87 e0       	ldi	r24, 0x07	; 7
 5bc:	80 93 46 04 	sts	0x0446, r24	; 0x800446 <__TEXT_REGION_LENGTH__+0x700446>
    PORTB_OUTCLR = 0x44;
 5c0:	84 e4       	ldi	r24, 0x44	; 68
 5c2:	80 93 26 04 	sts	0x0426, r24	; 0x800426 <__TEXT_REGION_LENGTH__+0x700426>
    "brlo .+2          \n"      //Quick fix
    "ldi r24, 251      \n"      //Quick fix
    */"st %a[wo]+, r24   \n"
    "dec r25           \n"
    "brne .-8         \n"
    :: [wo] "e" (&TCA0_SPLIT_LCMP0), [arr] "e" (&iLED[(L_COL<<3)]) : "r25", "r24", "cc", "memory");
 5c6:	ec b3       	in	r30, 0x1c	; 28
 5c8:	f0 e0       	ldi	r31, 0x00	; 0
 5ca:	ee 0f       	add	r30, r30
 5cc:	ff 1f       	adc	r31, r31
 5ce:	ee 0f       	add	r30, r30
 5d0:	ff 1f       	adc	r31, r31
 5d2:	ee 0f       	add	r30, r30
 5d4:	ff 1f       	adc	r31, r31
 5d6:	e4 59       	subi	r30, 0x94	; 148
 5d8:	f7 4c       	sbci	r31, 0xC7	; 199
    //Turn off all columns
    PORTC_OUTCLR = 0x07;
    PORTB_OUTCLR = 0x44;

    //Write all of the compare registers of TCA0 with PWM values in array (rows)
    asm(
 5da:	a8 e2       	ldi	r26, 0x28	; 40
 5dc:	ba e0       	ldi	r27, 0x0A	; 10
 5de:	96 e0       	ldi	r25, 0x06	; 6
 5e0:	81 91       	ld	r24, Z+
 5e2:	8d 93       	st	X+, r24
 5e4:	9a 95       	dec	r25
 5e6:	e1 f7       	brne	.-8      	; 0x5e0 <__vector_8+0x3c>
    */"st %a[wo]+, r24   \n"
    "dec r25           \n"
    "brne .-8         \n"
    :: [wo] "e" (&TCA0_SPLIT_LCMP0), [arr] "e" (&iLED[(L_COL<<3)]) : "r25", "r24", "cc", "memory");

    TCA0_SPLIT_CTRLESET = ((0x2)<<2)|0x3; //Sync timers: Moved this below the PWM value loading to fix the data shifting in asm above.
 5e8:	8b e0       	ldi	r24, 0x0B	; 11
 5ea:	80 93 05 0a 	sts	0x0A05, r24	; 0x800a05 <__TEXT_REGION_LENGTH__+0x700a05>

    //Turn on the right column
    if (L_COL<3) {
 5ee:	8c b3       	in	r24, 0x1c	; 28
 5f0:	83 30       	cpi	r24, 0x03	; 3
 5f2:	58 f4       	brcc	.+22     	; 0x60a <__vector_8+0x66>
        asm(
 5f4:	8c b3       	in	r24, 0x1c	; 28
 5f6:	91 e0       	ldi	r25, 0x01	; 1
 5f8:	01 c0       	rjmp	.+2      	; 0x5fc <__vector_8+0x58>
 5fa:	99 0f       	add	r25, r25
 5fc:	8a 95       	dec	r24
 5fe:	ea f7       	brpl	.-6      	; 0x5fa <__vector_8+0x56>
 600:	99 b9       	out	0x09, r25	; 9
 602:	8c b3       	in	r24, 0x1c	; 28
 604:	83 95       	inc	r24
 606:	8c bb       	out	0x1c, r24	; 28
 608:	0a c0       	rjmp	.+20     	; 0x61e <__vector_8+0x7a>
        "in r24, %[io0]  \n"
        "inc r24         \n"
        "out %[io0], r24 \n"
        :: [io0] "I" (&L_COL), [vpc] "I" (&VPORTC_OUT) : "r24", "r25", "cc");
        } else {
        asm(
 60a:	8c b3       	in	r24, 0x1c	; 28
 60c:	83 30       	cpi	r24, 0x03	; 3
 60e:	21 f4       	brne	.+8      	; 0x618 <__vector_8+0x74>
 610:	2a 9a       	sbi	0x05, 2	; 5
 612:	83 95       	inc	r24
 614:	8c bb       	out	0x1c, r24	; 28
 616:	03 c0       	rjmp	.+6      	; 0x61e <__vector_8+0x7a>
 618:	2e 9a       	sbi	0x05, 6	; 5
 61a:	88 27       	eor	r24, r24
 61c:	8c bb       	out	0x1c, r24	; 28
        "clr r24         \n"
        "out %[io0], r24 \n"
        :: [io0] "I" (&L_COL), [vpb] "I" (&VPORTB_OUT) : "r24", "cc");
    }
    
    if(timeout_I2C) timeout_I2C--;
 61e:	80 91 20 38 	lds	r24, 0x3820	; 0x803820 <timeout_I2C>
 622:	88 23       	and	r24, r24
 624:	29 f0       	breq	.+10     	; 0x630 <__vector_8+0x8c>
 626:	80 91 20 38 	lds	r24, 0x3820	; 0x803820 <timeout_I2C>
 62a:	81 50       	subi	r24, 0x01	; 1
 62c:	80 93 20 38 	sts	0x3820, r24	; 0x803820 <timeout_I2C>
    TCA0_SPLIT_INTFLAGS = 0xFF;
 630:	8f ef       	ldi	r24, 0xFF	; 255
 632:	80 93 0b 0a 	sts	0x0A0B, r24	; 0x800a0b <__TEXT_REGION_LENGTH__+0x700a0b>
}
 636:	ff 91       	pop	r31
 638:	ef 91       	pop	r30
 63a:	bf 91       	pop	r27
 63c:	af 91       	pop	r26
 63e:	9f 91       	pop	r25
 640:	8f 91       	pop	r24
 642:	0f 90       	pop	r0
 644:	0f be       	out	0x3f, r0	; 63
 646:	0f 90       	pop	r0
 648:	1f 90       	pop	r1
 64a:	18 95       	reti

0000064c <__vector_13>:

// TCB0 is used for (slowly) sending serial characters. A 0x00 character code is needed to terminate sending or it will leak memory to serial. It's a feature, honest! 
ISR(TCB0_INT_vect){
 64c:	1f 92       	push	r1
 64e:	0f 92       	push	r0
 650:	0f b6       	in	r0, 0x3f	; 63
 652:	0f 92       	push	r0
 654:	11 24       	eor	r1, r1
 656:	8f 93       	push	r24
 658:	9f 93       	push	r25
 65a:	ef 93       	push	r30
 65c:	ff 93       	push	r31
    if (*serTxAddr) {
 65e:	e0 91 45 38 	lds	r30, 0x3845	; 0x803845 <serTxAddr>
 662:	f0 91 46 38 	lds	r31, 0x3846	; 0x803846 <serTxAddr+0x1>
 666:	80 81       	ld	r24, Z
 668:	88 23       	and	r24, r24
 66a:	91 f0       	breq	.+36     	; 0x690 <__vector_13+0x44>
        USART0_TXDATAL = *serTxAddr;
 66c:	80 81       	ld	r24, Z
 66e:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <__TEXT_REGION_LENGTH__+0x700802>
        serTxAddr++;
 672:	80 91 45 38 	lds	r24, 0x3845	; 0x803845 <serTxAddr>
 676:	90 91 46 38 	lds	r25, 0x3846	; 0x803846 <serTxAddr+0x1>
 67a:	01 96       	adiw	r24, 0x01	; 1
 67c:	80 93 45 38 	sts	0x3845, r24	; 0x803845 <serTxAddr>
 680:	90 93 46 38 	sts	0x3846, r25	; 0x803846 <serTxAddr+0x1>
        USART0_CTRLA |= USART_DREIE_bm;
 684:	e5 e0       	ldi	r30, 0x05	; 5
 686:	f8 e0       	ldi	r31, 0x08	; 8
 688:	80 81       	ld	r24, Z
 68a:	80 62       	ori	r24, 0x20	; 32
 68c:	80 83       	st	Z, r24
 68e:	05 c0       	rjmp	.+10     	; 0x69a <__vector_13+0x4e>
    } else {
        serTxDone = 1;
 690:	81 e0       	ldi	r24, 0x01	; 1
 692:	80 93 00 38 	sts	0x3800, r24	; 0x803800 <__data_start>
        TCB0_INTCTRL = 0x00;
 696:	10 92 45 0a 	sts	0x0A45, r1	; 0x800a45 <__TEXT_REGION_LENGTH__+0x700a45>
    }
    TCB0_INTFLAGS = TCB_CAPT_bm;
 69a:	81 e0       	ldi	r24, 0x01	; 1
 69c:	80 93 46 0a 	sts	0x0A46, r24	; 0x800a46 <__TEXT_REGION_LENGTH__+0x700a46>
}
 6a0:	ff 91       	pop	r31
 6a2:	ef 91       	pop	r30
 6a4:	9f 91       	pop	r25
 6a6:	8f 91       	pop	r24
 6a8:	0f 90       	pop	r0
 6aa:	0f be       	out	0x3f, r0	; 63
 6ac:	0f 90       	pop	r0
 6ae:	1f 90       	pop	r1
 6b0:	18 95       	reti

000006b2 <__vector_14>:

// TCB1 is used for audio generation. Keeps playing "data" until 0 is reached. Audio sample data can contain 0x01 to 0xFF, centered around 0x80
ISR(TCB1_INT_vect){
 6b2:	1f 92       	push	r1
 6b4:	0f 92       	push	r0
 6b6:	0f b6       	in	r0, 0x3f	; 63
 6b8:	0f 92       	push	r0
 6ba:	11 24       	eor	r1, r1
 6bc:	8f 93       	push	r24
 6be:	9f 93       	push	r25
 6c0:	ef 93       	push	r30
 6c2:	ff 93       	push	r31
    if (*auSmpAddr) {
 6c4:	e0 91 41 38 	lds	r30, 0x3841	; 0x803841 <auSmpAddr>
 6c8:	f0 91 42 38 	lds	r31, 0x3842	; 0x803842 <auSmpAddr+0x1>
 6cc:	80 81       	ld	r24, Z
 6ce:	88 23       	and	r24, r24
 6d0:	69 f0       	breq	.+26     	; 0x6ec <__vector_14+0x3a>
        DAC0_DATA = *auSmpAddr;
 6d2:	80 81       	ld	r24, Z
 6d4:	80 93 a1 06 	sts	0x06A1, r24	; 0x8006a1 <__TEXT_REGION_LENGTH__+0x7006a1>
        auSmpAddr++;
 6d8:	80 91 41 38 	lds	r24, 0x3841	; 0x803841 <auSmpAddr>
 6dc:	90 91 42 38 	lds	r25, 0x3842	; 0x803842 <auSmpAddr+0x1>
 6e0:	01 96       	adiw	r24, 0x01	; 1
 6e2:	80 93 41 38 	sts	0x3841, r24	; 0x803841 <auSmpAddr>
 6e6:	90 93 42 38 	sts	0x3842, r25	; 0x803842 <auSmpAddr+0x1>
 6ea:	06 c0       	rjmp	.+12     	; 0x6f8 <__vector_14+0x46>
        } else {
        DAC0_DATA = 0x80;
 6ec:	80 e8       	ldi	r24, 0x80	; 128
 6ee:	80 93 a1 06 	sts	0x06A1, r24	; 0x8006a1 <__TEXT_REGION_LENGTH__+0x7006a1>
        auPlayDone = 1;
 6f2:	81 e0       	ldi	r24, 0x01	; 1
 6f4:	80 93 94 38 	sts	0x3894, r24	; 0x803894 <auPlayDone>
    }
    TCB1_INTFLAGS = TCB_CAPT_bm;
 6f8:	81 e0       	ldi	r24, 0x01	; 1
 6fa:	80 93 56 0a 	sts	0x0A56, r24	; 0x800a56 <__TEXT_REGION_LENGTH__+0x700a56>
}
 6fe:	ff 91       	pop	r31
 700:	ef 91       	pop	r30
 702:	9f 91       	pop	r25
 704:	8f 91       	pop	r24
 706:	0f 90       	pop	r0
 708:	0f be       	out	0x3f, r0	; 63
 70a:	0f 90       	pop	r0
 70c:	1f 90       	pop	r1
 70e:	18 95       	reti

00000710 <__vector_27>:

// Reads up to RXLEN characters until LF is found, LF sets the serRxDone flag and writes 0 instead of LF.
ISR(USART0_RXC_vect){
 710:	1f 92       	push	r1
 712:	0f 92       	push	r0
 714:	0f b6       	in	r0, 0x3f	; 63
 716:	0f 92       	push	r0
 718:	11 24       	eor	r1, r1
 71a:	8f 93       	push	r24
 71c:	ef 93       	push	r30
 71e:	ff 93       	push	r31
    serRx[RXCNT] = USART0.RXDATAL;
 720:	ed b3       	in	r30, 0x1d	; 29
 722:	f0 e0       	ldi	r31, 0x00	; 0
 724:	80 91 00 08 	lds	r24, 0x0800	; 0x800800 <__TEXT_REGION_LENGTH__+0x700800>
 728:	ef 5d       	subi	r30, 0xDF	; 223
 72a:	f7 4c       	sbci	r31, 0xC7	; 199
 72c:	80 83       	st	Z, r24
    if (serRx[RXCNT] == 0x0A){
 72e:	ed b3       	in	r30, 0x1d	; 29
 730:	f0 e0       	ldi	r31, 0x00	; 0
 732:	ef 5d       	subi	r30, 0xDF	; 223
 734:	f7 4c       	sbci	r31, 0xC7	; 199
 736:	80 81       	ld	r24, Z
 738:	8a 30       	cpi	r24, 0x0A	; 10
 73a:	49 f4       	brne	.+18     	; 0x74e <__vector_27+0x3e>
        serRx[RXCNT] = 0;
 73c:	ed b3       	in	r30, 0x1d	; 29
 73e:	f0 e0       	ldi	r31, 0x00	; 0
 740:	ef 5d       	subi	r30, 0xDF	; 223
 742:	f7 4c       	sbci	r31, 0xC7	; 199
 744:	10 82       	st	Z, r1
        serRxDone = 1;
 746:	81 e0       	ldi	r24, 0x01	; 1
 748:	80 93 1d 38 	sts	0x381D, r24	; 0x80381d <serRxDone>
 74c:	06 c0       	rjmp	.+12     	; 0x75a <__vector_27+0x4a>
    } else if (RXCNT < (RXLEN-1)) RXCNT++;
 74e:	8d b3       	in	r24, 0x1d	; 29
 750:	8f 31       	cpi	r24, 0x1F	; 31
 752:	18 f4       	brcc	.+6      	; 0x75a <__vector_27+0x4a>
 754:	8d b3       	in	r24, 0x1d	; 29
 756:	8f 5f       	subi	r24, 0xFF	; 255
 758:	8d bb       	out	0x1d, r24	; 29
    USART0_STATUS = USART_RXCIF_bm;
 75a:	80 e8       	ldi	r24, 0x80	; 128
 75c:	80 93 04 08 	sts	0x0804, r24	; 0x800804 <__TEXT_REGION_LENGTH__+0x700804>
};
 760:	ff 91       	pop	r31
 762:	ef 91       	pop	r30
 764:	8f 91       	pop	r24
 766:	0f 90       	pop	r0
 768:	0f be       	out	0x3f, r0	; 63
 76a:	0f 90       	pop	r0
 76c:	1f 90       	pop	r1
 76e:	18 95       	reti

00000770 <__vector_28>:

// Trigger new data write and turn off DRE interrupt.
ISR(USART0_DRE_vect){
 770:	1f 92       	push	r1
 772:	0f 92       	push	r0
 774:	0f b6       	in	r0, 0x3f	; 63
 776:	0f 92       	push	r0
 778:	11 24       	eor	r1, r1
 77a:	8f 93       	push	r24
 77c:	ef 93       	push	r30
 77e:	ff 93       	push	r31
    TCB0_CNT = 0;
 780:	10 92 4a 0a 	sts	0x0A4A, r1	; 0x800a4a <__TEXT_REGION_LENGTH__+0x700a4a>
 784:	10 92 4b 0a 	sts	0x0A4B, r1	; 0x800a4b <__TEXT_REGION_LENGTH__+0x700a4b>
    TCB0_INTCTRL = 0x01;
 788:	81 e0       	ldi	r24, 0x01	; 1
 78a:	80 93 45 0a 	sts	0x0A45, r24	; 0x800a45 <__TEXT_REGION_LENGTH__+0x700a45>
    USART0_CTRLA &= ~(USART_DREIE_bm);
 78e:	e5 e0       	ldi	r30, 0x05	; 5
 790:	f8 e0       	ldi	r31, 0x08	; 8
 792:	80 81       	ld	r24, Z
 794:	8f 7d       	andi	r24, 0xDF	; 223
 796:	80 83       	st	Z, r24
};
 798:	ff 91       	pop	r31
 79a:	ef 91       	pop	r30
 79c:	8f 91       	pop	r24
 79e:	0f 90       	pop	r0
 7a0:	0f be       	out	0x3f, r0	; 63
 7a2:	0f 90       	pop	r0
 7a4:	1f 90       	pop	r1
 7a6:	18 95       	reti

000007a8 <__vector_20>:

// ADC used for audio input and temperature sensor.
ISR(ADC0_RESRDY_vect){
 7a8:	1f 92       	push	r1
 7aa:	0f 92       	push	r0
 7ac:	0f b6       	in	r0, 0x3f	; 63
 7ae:	0f 92       	push	r0
 7b0:	11 24       	eor	r1, r1
 7b2:	8f 93       	push	r24
 7b4:	ef 93       	push	r30
 7b6:	ff 93       	push	r31
    AUPOS = (AUPOS+1)&(AULEN-1);
 7b8:	8e b3       	in	r24, 0x1e	; 30
 7ba:	8f 5f       	subi	r24, 0xFF	; 255
 7bc:	8f 71       	andi	r24, 0x1F	; 31
 7be:	8e bb       	out	0x1e, r24	; 30
    if (adc0Chg == 0){
 7c0:	80 91 1a 38 	lds	r24, 0x381A	; 0x80381a <__data_end>
 7c4:	81 11       	cpse	r24, r1
 7c6:	11 c0       	rjmp	.+34     	; 0x7ea <__vector_20+0x42>
        if (ADC0_MUXPOS == 0x1E) adcTemp = ADC0_RESL; else auIn[AUPOS]=ADC0_RESL;
 7c8:	80 91 06 06 	lds	r24, 0x0606	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
 7cc:	8e 31       	cpi	r24, 0x1E	; 30
 7ce:	29 f4       	brne	.+10     	; 0x7da <__vector_20+0x32>
 7d0:	80 91 10 06 	lds	r24, 0x0610	; 0x800610 <__TEXT_REGION_LENGTH__+0x700610>
 7d4:	80 93 95 38 	sts	0x3895, r24	; 0x803895 <adcTemp>
 7d8:	0a c0       	rjmp	.+20     	; 0x7ee <__vector_20+0x46>
 7da:	ee b3       	in	r30, 0x1e	; 30
 7dc:	f0 e0       	ldi	r31, 0x00	; 0
 7de:	80 91 10 06 	lds	r24, 0x0610	; 0x800610 <__TEXT_REGION_LENGTH__+0x700610>
 7e2:	e4 5b       	subi	r30, 0xB4	; 180
 7e4:	f7 4c       	sbci	r31, 0xC7	; 199
 7e6:	80 83       	st	Z, r24
 7e8:	02 c0       	rjmp	.+4      	; 0x7ee <__vector_20+0x46>
    } else adc0Chg = 0;
 7ea:	10 92 1a 38 	sts	0x381A, r1	; 0x80381a <__data_end>
    ADC0_INTFLAGS = ADC_RESRDY_bm;
 7ee:	81 e0       	ldi	r24, 0x01	; 1
 7f0:	80 93 0b 06 	sts	0x060B, r24	; 0x80060b <__TEXT_REGION_LENGTH__+0x70060b>
}
 7f4:	ff 91       	pop	r31
 7f6:	ef 91       	pop	r30
 7f8:	8f 91       	pop	r24
 7fa:	0f 90       	pop	r0
 7fc:	0f be       	out	0x3f, r0	; 63
 7fe:	0f 90       	pop	r0
 800:	1f 90       	pop	r1
 802:	18 95       	reti

00000804 <__vector_22>:

// Reads out sensors at 8Hz and buttons at 42Hz (timed by PIT), power for the sensors is on 1/8th of the time to save power.
ISR(ADC1_RESRDY_vect){
 804:	1f 92       	push	r1
 806:	0f 92       	push	r0
 808:	0f b6       	in	r0, 0x3f	; 63
 80a:	0f 92       	push	r0
 80c:	11 24       	eor	r1, r1
 80e:	8f 93       	push	r24
 810:	9f 93       	push	r25
    if (ADC1_MUXPOS == 0) {
 812:	80 91 46 06 	lds	r24, 0x0646	; 0x800646 <__TEXT_REGION_LENGTH__+0x700646>
 816:	81 11       	cpse	r24, r1
 818:	0c c0       	rjmp	.+24     	; 0x832 <__vector_22+0x2e>
        adcPhot = ADC1_RES;
 81a:	80 91 50 06 	lds	r24, 0x0650	; 0x800650 <__TEXT_REGION_LENGTH__+0x700650>
 81e:	90 91 51 06 	lds	r25, 0x0651	; 0x800651 <__TEXT_REGION_LENGTH__+0x700651>
 822:	80 93 49 38 	sts	0x3849, r24	; 0x803849 <adcPhot>
 826:	90 93 4a 38 	sts	0x384A, r25	; 0x80384a <adcPhot+0x1>
        ADC1_MUXPOS = 0x01;             //Select Hall sensor
 82a:	81 e0       	ldi	r24, 0x01	; 1
 82c:	80 93 46 06 	sts	0x0646, r24	; 0x800646 <__TEXT_REGION_LENGTH__+0x700646>
 830:	23 c0       	rjmp	.+70     	; 0x878 <__vector_22+0x74>
    } else if (ADC1_MUXPOS == 1){
 832:	80 91 46 06 	lds	r24, 0x0646	; 0x800646 <__TEXT_REGION_LENGTH__+0x700646>
 836:	81 30       	cpi	r24, 0x01	; 1
 838:	79 f4       	brne	.+30     	; 0x858 <__vector_22+0x54>
        PORTA_OUTCLR = 0b00001000;      //Turn off sensor power
 83a:	88 e0       	ldi	r24, 0x08	; 8
 83c:	80 93 06 04 	sts	0x0406, r24	; 0x800406 <__TEXT_REGION_LENGTH__+0x700406>
        adcHall = ADC1_RES;
 840:	80 91 50 06 	lds	r24, 0x0650	; 0x800650 <__TEXT_REGION_LENGTH__+0x700650>
 844:	90 91 51 06 	lds	r25, 0x0651	; 0x800651 <__TEXT_REGION_LENGTH__+0x700651>
 848:	80 93 47 38 	sts	0x3847, r24	; 0x803847 <adcHall>
 84c:	90 93 48 38 	sts	0x3848, r25	; 0x803848 <adcHall+0x1>
        ADC1_MUXPOS = 0x04;             //select buttons
 850:	84 e0       	ldi	r24, 0x04	; 4
 852:	80 93 46 06 	sts	0x0646, r24	; 0x800646 <__TEXT_REGION_LENGTH__+0x700646>
 856:	10 c0       	rjmp	.+32     	; 0x878 <__vector_22+0x74>
    } else {
        adcBtns = ADC1_RES;
 858:	80 91 50 06 	lds	r24, 0x0650	; 0x800650 <__TEXT_REGION_LENGTH__+0x700650>
 85c:	90 91 51 06 	lds	r25, 0x0651	; 0x800651 <__TEXT_REGION_LENGTH__+0x700651>
 860:	80 93 43 38 	sts	0x3843, r24	; 0x803843 <adcBtns>
 864:	90 93 44 38 	sts	0x3844, r25	; 0x803844 <adcBtns+0x1>
        if (A1CNT == 15){
 868:	8f b3       	in	r24, 0x1f	; 31
 86a:	8f 30       	cpi	r24, 0x0F	; 15
 86c:	29 f4       	brne	.+10     	; 0x878 <__vector_22+0x74>
            ADC1_MUXPOS = 0x00;         //Select photo transistor
 86e:	10 92 46 06 	sts	0x0646, r1	; 0x800646 <__TEXT_REGION_LENGTH__+0x700646>
            PORTA_OUTSET = 0b00001000;  //Turn on sensor power
 872:	88 e0       	ldi	r24, 0x08	; 8
 874:	80 93 05 04 	sts	0x0405, r24	; 0x800405 <__TEXT_REGION_LENGTH__+0x700405>
        }
    }

    A1CNT=(A1CNT+1)%16;        
 878:	8f b3       	in	r24, 0x1f	; 31
 87a:	90 e0       	ldi	r25, 0x00	; 0
 87c:	01 96       	adiw	r24, 0x01	; 1
 87e:	8f 70       	andi	r24, 0x0F	; 15
 880:	90 78       	andi	r25, 0x80	; 128
 882:	99 23       	and	r25, r25
 884:	24 f4       	brge	.+8      	; 0x88e <__vector_22+0x8a>
 886:	01 97       	sbiw	r24, 0x01	; 1
 888:	80 6f       	ori	r24, 0xF0	; 240
 88a:	9f 6f       	ori	r25, 0xFF	; 255
 88c:	01 96       	adiw	r24, 0x01	; 1
 88e:	8f bb       	out	0x1f, r24	; 31
    ADC1_INTFLAGS = ADC_RESRDY_bm;
 890:	81 e0       	ldi	r24, 0x01	; 1
 892:	80 93 4b 06 	sts	0x064B, r24	; 0x80064b <__TEXT_REGION_LENGTH__+0x70064b>
}
 896:	9f 91       	pop	r25
 898:	8f 91       	pop	r24
 89a:	0f 90       	pop	r0
 89c:	0f be       	out	0x3f, r0	; 63
 89e:	0f 90       	pop	r0
 8a0:	1f 90       	pop	r1
 8a2:	18 95       	reti

000008a4 <__vector_6>:

//RTC compare interrupt, triggers at 512/BTN_TMR rate, also RTC overflow interrupt, triggers once a minute
ISR(RTC_CNT_vect) {
 8a4:	1f 92       	push	r1
 8a6:	0f 92       	push	r0
 8a8:	0f b6       	in	r0, 0x3f	; 63
 8aa:	0f 92       	push	r0
 8ac:	11 24       	eor	r1, r1
 8ae:	5f 93       	push	r21
 8b0:	6f 93       	push	r22
 8b2:	7f 93       	push	r23
 8b4:	8f 93       	push	r24
 8b6:	9f 93       	push	r25
 8b8:	af 93       	push	r26
 8ba:	bf 93       	push	r27
 8bc:	ef 93       	push	r30
 8be:	ff 93       	push	r31
    if (RTC_INTFLAGS & RTC_CMP_bm){
 8c0:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <__TEXT_REGION_LENGTH__+0x700143>
 8c4:	81 ff       	sbrs	r24, 1
 8c6:	28 c0       	rjmp	.+80     	; 0x918 <__vector_6+0x74>
        if (buttonMark<255) buttonMark++;   // For button timing purposes
 8c8:	80 91 1b 38 	lds	r24, 0x381B	; 0x80381b <buttonMark>
 8cc:	8f 3f       	cpi	r24, 0xFF	; 255
 8ce:	29 f0       	breq	.+10     	; 0x8da <__vector_6+0x36>
 8d0:	80 91 1b 38 	lds	r24, 0x381B	; 0x80381b <buttonMark>
 8d4:	8f 5f       	subi	r24, 0xFF	; 255
 8d6:	80 93 1b 38 	sts	0x381B, r24	; 0x80381b <buttonMark>
        tmp16bit = (RTC_CNT + BTN_TMR)%RTC_PER;
 8da:	80 91 48 01 	lds	r24, 0x0148	; 0x800148 <__TEXT_REGION_LENGTH__+0x700148>
 8de:	90 91 49 01 	lds	r25, 0x0149	; 0x800149 <__TEXT_REGION_LENGTH__+0x700149>
 8e2:	60 91 4a 01 	lds	r22, 0x014A	; 0x80014a <__TEXT_REGION_LENGTH__+0x70014a>
 8e6:	70 91 4b 01 	lds	r23, 0x014B	; 0x80014b <__TEXT_REGION_LENGTH__+0x70014b>
 8ea:	82 96       	adiw	r24, 0x22	; 34
 8ec:	03 d3       	rcall	.+1542   	; 0xef4 <__udivmodhi4>
 8ee:	80 93 96 38 	sts	0x3896, r24	; 0x803896 <tmp16bit>
 8f2:	90 93 97 38 	sts	0x3897, r25	; 0x803897 <tmp16bit+0x1>
        while(RTC_STATUS & RTC_CMPBUSY_bm);
 8f6:	e1 e4       	ldi	r30, 0x41	; 65
 8f8:	f1 e0       	ldi	r31, 0x01	; 1
 8fa:	80 81       	ld	r24, Z
 8fc:	83 fd       	sbrc	r24, 3
 8fe:	fd cf       	rjmp	.-6      	; 0x8fa <__vector_6+0x56>
        RTC_CMP = tmp16bit;                 // Button timing: next interrupt set
 900:	80 91 96 38 	lds	r24, 0x3896	; 0x803896 <tmp16bit>
 904:	90 91 97 38 	lds	r25, 0x3897	; 0x803897 <tmp16bit+0x1>
 908:	80 93 4c 01 	sts	0x014C, r24	; 0x80014c <__TEXT_REGION_LENGTH__+0x70014c>
 90c:	90 93 4d 01 	sts	0x014D, r25	; 0x80014d <__TEXT_REGION_LENGTH__+0x70014d>
        RTC_INTFLAGS = RTC_CMP_bm;		    // clear interrupt flag
 910:	82 e0       	ldi	r24, 0x02	; 2
 912:	80 93 43 01 	sts	0x0143, r24	; 0x800143 <__TEXT_REGION_LENGTH__+0x700143>
 916:	0c c0       	rjmp	.+24     	; 0x930 <__vector_6+0x8c>
    } else {
        if (minuteMark<255) minuteMark++;   // For very slow timing purposes
 918:	80 91 1c 38 	lds	r24, 0x381C	; 0x80381c <minuteMark>
 91c:	8f 3f       	cpi	r24, 0xFF	; 255
 91e:	29 f0       	breq	.+10     	; 0x92a <__vector_6+0x86>
 920:	80 91 1c 38 	lds	r24, 0x381C	; 0x80381c <minuteMark>
 924:	8f 5f       	subi	r24, 0xFF	; 255
 926:	80 93 1c 38 	sts	0x381C, r24	; 0x80381c <minuteMark>
        RTC_INTFLAGS = RTC_OVF_bm;		    // clear interrupt flag
 92a:	81 e0       	ldi	r24, 0x01	; 1
 92c:	80 93 43 01 	sts	0x0143, r24	; 0x800143 <__TEXT_REGION_LENGTH__+0x700143>
    }
}
 930:	ff 91       	pop	r31
 932:	ef 91       	pop	r30
 934:	bf 91       	pop	r27
 936:	af 91       	pop	r26
 938:	9f 91       	pop	r25
 93a:	8f 91       	pop	r24
 93c:	7f 91       	pop	r23
 93e:	6f 91       	pop	r22
 940:	5f 91       	pop	r21
 942:	0f 90       	pop	r0
 944:	0f be       	out	0x3f, r0	; 63
 946:	0f 90       	pop	r0
 948:	1f 90       	pop	r1
 94a:	18 95       	reti

0000094c <__vector_7>:

//PIT interrupt (timing of ADC0: audio/temperature value)
ISR(RTC_PIT_vect) {						// PIT interrupt handling code
 94c:	1f 92       	push	r1
 94e:	0f 92       	push	r0
 950:	0f b6       	in	r0, 0x3f	; 63
 952:	0f 92       	push	r0
 954:	11 24       	eor	r1, r1
 956:	8f 93       	push	r24
    ADC1_COMMAND = 0x01;
 958:	81 e0       	ldi	r24, 0x01	; 1
 95a:	80 93 48 06 	sts	0x0648, r24	; 0x800648 <__TEXT_REGION_LENGTH__+0x700648>
    RTC_PITINTFLAGS = RTC_PI_bm;		// clear interrupt flag
 95e:	80 93 53 01 	sts	0x0153, r24	; 0x800153 <__TEXT_REGION_LENGTH__+0x700153>
}
 962:	8f 91       	pop	r24
 964:	0f 90       	pop	r0
 966:	0f be       	out	0x3f, r0	; 63
 968:	0f 90       	pop	r0
 96a:	1f 90       	pop	r1
 96c:	18 95       	reti

0000096e <EERead>:

//Read bytes from EEPROM
void EERead(uint8_t eeAddr, uint8_t *eeValues, uint8_t size)
{
    while(NVMCTRL_STATUS & NVMCTRL_EEBUSY_bm);              // Wait until any write operation has finished
 96e:	e2 e0       	ldi	r30, 0x02	; 2
 970:	f0 e1       	ldi	r31, 0x10	; 16
 972:	90 81       	ld	r25, Z
 974:	91 fd       	sbrc	r25, 1
 976:	fd cf       	rjmp	.-6      	; 0x972 <EERead+0x4>

    while(size){
 978:	44 23       	and	r20, r20
 97a:	59 f0       	breq	.+22     	; 0x992 <EERead+0x24>
 97c:	a6 2f       	mov	r26, r22
 97e:	b7 2f       	mov	r27, r23
 980:	48 0f       	add	r20, r24
        *eeValues++ = *(uint8_t *)(EEPROM_START+eeAddr++);  // Read data from buffer
 982:	e8 2f       	mov	r30, r24
 984:	f0 e0       	ldi	r31, 0x00	; 0
 986:	fc 5e       	subi	r31, 0xEC	; 236
 988:	90 81       	ld	r25, Z
 98a:	9d 93       	st	X+, r25
 98c:	8f 5f       	subi	r24, 0xFF	; 255
//Read bytes from EEPROM
void EERead(uint8_t eeAddr, uint8_t *eeValues, uint8_t size)
{
    while(NVMCTRL_STATUS & NVMCTRL_EEBUSY_bm);              // Wait until any write operation has finished

    while(size){
 98e:	48 13       	cpse	r20, r24
 990:	f8 cf       	rjmp	.-16     	; 0x982 <EERead+0x14>
 992:	08 95       	ret

00000994 <EEWrite>:
    }
}

//Write bytes to the EEPROM, if address exceeds EEPROM space data wraps around
uint8_t EEWrite(uint8_t eeAddr, uint8_t *eeValues, uint8_t size)
{
 994:	ff 92       	push	r15
 996:	0f 93       	push	r16
 998:	1f 93       	push	r17
 99a:	cf 93       	push	r28
 99c:	df 93       	push	r29
 99e:	e8 2f       	mov	r30, r24
    uint8_t lastByteOfPage;
    while(size){
 9a0:	44 23       	and	r20, r20
 9a2:	79 f1       	breq	.+94     	; 0xa02 <EEWrite+0x6e>
        lastByteOfPage = 0;
        while(NVMCTRL_STATUS & NVMCTRL_EEBUSY_bm);              // Wait until any write operation has finished
 9a4:	c2 e0       	ldi	r28, 0x02	; 2
 9a6:	d0 e1       	ldi	r29, 0x10	; 16
        CCP = CCP_SPM_gc;                                       // Gain access to NVMCTRL_CTRLA
 9a8:	3d e9       	ldi	r19, 0x9D	; 157
        NVMCTRL_CTRLA = NVMCTRL_CMD_PAGEBUFCLR_gc;              // Clear page buffer
 9aa:	00 e0       	ldi	r16, 0x00	; 0
 9ac:	10 e1       	ldi	r17, 0x10	; 16
 9ae:	54 e0       	ldi	r21, 0x04	; 4
            if ((eeAddr % EEPROM_PAGE_SIZE) == (EEPROM_PAGE_SIZE-1)) lastByteOfPage = 1;
            *(uint8_t *)(EEPROM_START+eeAddr++) = *eeValues++;  // Write data to buffer
            --size;
        }
        CCP = CCP_SPM_gc;
        NVMCTRL_CTRLA = NVMCTRL_CMD_PAGEERASEWRITE_gc;          // Erase old data and write new data to EEPROM
 9b0:	0f 2e       	mov	r0, r31
 9b2:	f3 e0       	ldi	r31, 0x03	; 3
 9b4:	ff 2e       	mov	r15, r31
 9b6:	f0 2d       	mov	r31, r0
uint8_t EEWrite(uint8_t eeAddr, uint8_t *eeValues, uint8_t size)
{
    uint8_t lastByteOfPage;
    while(size){
        lastByteOfPage = 0;
        while(NVMCTRL_STATUS & NVMCTRL_EEBUSY_bm);              // Wait until any write operation has finished
 9b8:	88 81       	ld	r24, Y
 9ba:	81 fd       	sbrc	r24, 1
 9bc:	fd cf       	rjmp	.-6      	; 0x9b8 <EEWrite+0x24>
        CCP = CCP_SPM_gc;                                       // Gain access to NVMCTRL_CTRLA
 9be:	34 bf       	out	0x34, r19	; 52
        NVMCTRL_CTRLA = NVMCTRL_CMD_PAGEBUFCLR_gc;              // Clear page buffer
 9c0:	d8 01       	movw	r26, r16
 9c2:	5c 93       	st	X, r21
        while((size) && (lastByteOfPage == 0)){
 9c4:	44 23       	and	r20, r20
 9c6:	91 f0       	breq	.+36     	; 0x9ec <EEWrite+0x58>
            if ((eeAddr % EEPROM_PAGE_SIZE) == (EEPROM_PAGE_SIZE-1)) lastByteOfPage = 1;
 9c8:	2e 2f       	mov	r18, r30
 9ca:	2f 71       	andi	r18, 0x1F	; 31
            *(uint8_t *)(EEPROM_START+eeAddr++) = *eeValues++;  // Write data to buffer
 9cc:	91 e0       	ldi	r25, 0x01	; 1
 9ce:	9e 0f       	add	r25, r30
 9d0:	6f 5f       	subi	r22, 0xFF	; 255
 9d2:	7f 4f       	sbci	r23, 0xFF	; 255
 9d4:	db 01       	movw	r26, r22
 9d6:	11 97       	sbiw	r26, 0x01	; 1
 9d8:	8c 91       	ld	r24, X
 9da:	f0 e0       	ldi	r31, 0x00	; 0
 9dc:	fc 5e       	subi	r31, 0xEC	; 236
 9de:	80 83       	st	Z, r24
            --size;
 9e0:	41 50       	subi	r20, 0x01	; 1
    while(size){
        lastByteOfPage = 0;
        while(NVMCTRL_STATUS & NVMCTRL_EEBUSY_bm);              // Wait until any write operation has finished
        CCP = CCP_SPM_gc;                                       // Gain access to NVMCTRL_CTRLA
        NVMCTRL_CTRLA = NVMCTRL_CMD_PAGEBUFCLR_gc;              // Clear page buffer
        while((size) && (lastByteOfPage == 0)){
 9e2:	21 f0       	breq	.+8      	; 0x9ec <EEWrite+0x58>
            if ((eeAddr % EEPROM_PAGE_SIZE) == (EEPROM_PAGE_SIZE-1)) lastByteOfPage = 1;
            *(uint8_t *)(EEPROM_START+eeAddr++) = *eeValues++;  // Write data to buffer
 9e4:	e9 2f       	mov	r30, r25
    while(size){
        lastByteOfPage = 0;
        while(NVMCTRL_STATUS & NVMCTRL_EEBUSY_bm);              // Wait until any write operation has finished
        CCP = CCP_SPM_gc;                                       // Gain access to NVMCTRL_CTRLA
        NVMCTRL_CTRLA = NVMCTRL_CMD_PAGEBUFCLR_gc;              // Clear page buffer
        while((size) && (lastByteOfPage == 0)){
 9e6:	2f 31       	cpi	r18, 0x1F	; 31
 9e8:	79 f7       	brne	.-34     	; 0x9c8 <EEWrite+0x34>
 9ea:	0f c0       	rjmp	.+30     	; 0xa0a <EEWrite+0x76>
            if ((eeAddr % EEPROM_PAGE_SIZE) == (EEPROM_PAGE_SIZE-1)) lastByteOfPage = 1;
            *(uint8_t *)(EEPROM_START+eeAddr++) = *eeValues++;  // Write data to buffer
            --size;
        }
        CCP = CCP_SPM_gc;
 9ec:	8d e9       	ldi	r24, 0x9D	; 157
 9ee:	84 bf       	out	0x34, r24	; 52
        NVMCTRL_CTRLA = NVMCTRL_CMD_PAGEERASEWRITE_gc;          // Erase old data and write new data to EEPROM
 9f0:	83 e0       	ldi	r24, 0x03	; 3
 9f2:	80 93 00 10 	sts	0x1000, r24	; 0x801000 <__TEXT_REGION_LENGTH__+0x701000>
        if (NVMCTRL_STATUS & NVMCTRL_WRERROR_bm) return 1;
 9f6:	80 91 02 10 	lds	r24, 0x1002	; 0x801002 <__TEXT_REGION_LENGTH__+0x701002>
 9fa:	82 fb       	bst	r24, 2
 9fc:	88 27       	eor	r24, r24
 9fe:	80 f9       	bld	r24, 0
 a00:	0c c0       	rjmp	.+24     	; 0xa1a <EEWrite+0x86>
    }
    return 0;
 a02:	80 e0       	ldi	r24, 0x00	; 0
 a04:	0a c0       	rjmp	.+20     	; 0xa1a <EEWrite+0x86>
            *(uint8_t *)(EEPROM_START+eeAddr++) = *eeValues++;  // Write data to buffer
            --size;
        }
        CCP = CCP_SPM_gc;
        NVMCTRL_CTRLA = NVMCTRL_CMD_PAGEERASEWRITE_gc;          // Erase old data and write new data to EEPROM
        if (NVMCTRL_STATUS & NVMCTRL_WRERROR_bm) return 1;
 a06:	81 e0       	ldi	r24, 0x01	; 1
 a08:	08 c0       	rjmp	.+16     	; 0xa1a <EEWrite+0x86>
        while((size) && (lastByteOfPage == 0)){
            if ((eeAddr % EEPROM_PAGE_SIZE) == (EEPROM_PAGE_SIZE-1)) lastByteOfPage = 1;
            *(uint8_t *)(EEPROM_START+eeAddr++) = *eeValues++;  // Write data to buffer
            --size;
        }
        CCP = CCP_SPM_gc;
 a0a:	34 bf       	out	0x34, r19	; 52
        NVMCTRL_CTRLA = NVMCTRL_CMD_PAGEERASEWRITE_gc;          // Erase old data and write new data to EEPROM
 a0c:	f8 01       	movw	r30, r16
 a0e:	f0 82       	st	Z, r15
        if (NVMCTRL_STATUS & NVMCTRL_WRERROR_bm) return 1;
 a10:	88 81       	ld	r24, Y
 a12:	82 fd       	sbrc	r24, 2
 a14:	f8 cf       	rjmp	.-16     	; 0xa06 <EEWrite+0x72>
        while(NVMCTRL_STATUS & NVMCTRL_EEBUSY_bm);              // Wait until any write operation has finished
        CCP = CCP_SPM_gc;                                       // Gain access to NVMCTRL_CTRLA
        NVMCTRL_CTRLA = NVMCTRL_CMD_PAGEBUFCLR_gc;              // Clear page buffer
        while((size) && (lastByteOfPage == 0)){
            if ((eeAddr % EEPROM_PAGE_SIZE) == (EEPROM_PAGE_SIZE-1)) lastByteOfPage = 1;
            *(uint8_t *)(EEPROM_START+eeAddr++) = *eeValues++;  // Write data to buffer
 a16:	e9 2f       	mov	r30, r25
 a18:	cf cf       	rjmp	.-98     	; 0x9b8 <EEWrite+0x24>
        CCP = CCP_SPM_gc;
        NVMCTRL_CTRLA = NVMCTRL_CMD_PAGEERASEWRITE_gc;          // Erase old data and write new data to EEPROM
        if (NVMCTRL_STATUS & NVMCTRL_WRERROR_bm) return 1;
    }
    return 0;
}
 a1a:	df 91       	pop	r29
 a1c:	cf 91       	pop	r28
 a1e:	1f 91       	pop	r17
 a20:	0f 91       	pop	r16
 a22:	ff 90       	pop	r15
 a24:	08 95       	ret

00000a26 <SerSend>:

//Sends a set of characters to the serial port, stops only when character value 0 is reached.
uint8_t SerSend(unsigned char *addr){
 a26:	9c 01       	movw	r18, r24
    if (serTxDone){
 a28:	90 91 00 38 	lds	r25, 0x3800	; 0x803800 <__data_start>
 a2c:	99 23       	and	r25, r25
 a2e:	59 f0       	breq	.+22     	; 0xa46 <SerSend+0x20>
        serTxAddr = addr;
 a30:	20 93 45 38 	sts	0x3845, r18	; 0x803845 <serTxAddr>
 a34:	30 93 46 38 	sts	0x3846, r19	; 0x803846 <serTxAddr+0x1>
        serTxDone = 0;
 a38:	10 92 00 38 	sts	0x3800, r1	; 0x803800 <__data_start>
        TCB0_INTCTRL = 0x01;
 a3c:	81 e0       	ldi	r24, 0x01	; 1
 a3e:	80 93 45 0a 	sts	0x0A45, r24	; 0x800a45 <__TEXT_REGION_LENGTH__+0x700a45>
        return 0;
 a42:	80 e0       	ldi	r24, 0x00	; 0
 a44:	08 95       	ret
    } else return 1;    //Error: Still sending data
 a46:	81 e0       	ldi	r24, 0x01	; 1
};
 a48:	08 95       	ret

00000a4a <SerSpeed>:

// Set serial character output speed, 255-0 (0.8 to 100ms delay between characters)
void SerSpeed(uint8_t serSpd){
 a4a:	28 2f       	mov	r18, r24
    if (serSpd<1) serSpd = 1;
 a4c:	81 11       	cpse	r24, r1
 a4e:	01 c0       	rjmp	.+2      	; 0xa52 <SerSpeed+0x8>
 a50:	21 e0       	ldi	r18, 0x01	; 1
    TCB0_CCMP = ((uint16_t)(0xFF-serSpd)<<8) + 0xFF;
 a52:	8f ef       	ldi	r24, 0xFF	; 255
 a54:	90 e0       	ldi	r25, 0x00	; 0
 a56:	82 1b       	sub	r24, r18
 a58:	91 09       	sbc	r25, r1
 a5a:	98 2f       	mov	r25, r24
 a5c:	88 27       	eor	r24, r24
 a5e:	81 50       	subi	r24, 0x01	; 1
 a60:	9f 4f       	sbci	r25, 0xFF	; 255
 a62:	80 93 4c 0a 	sts	0x0A4C, r24	; 0x800a4c <__TEXT_REGION_LENGTH__+0x700a4c>
 a66:	90 93 4d 0a 	sts	0x0A4D, r25	; 0x800a4d <__TEXT_REGION_LENGTH__+0x700a4d>
 a6a:	08 95       	ret

00000a6c <SelectTSens>:
};

// Select temperature sensor
void SelectTSens(){
     VREF_CTRLA   = 0x12;    //0x22 for audio in/out (2.5V), 0x12 for temperature in, audio out (1.1V/2.5V)
 a6c:	82 e1       	ldi	r24, 0x12	; 18
 a6e:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
     ADC0_CTRLA   |= ADC_RESSEL_bm;
 a72:	e0 e0       	ldi	r30, 0x00	; 0
 a74:	f6 e0       	ldi	r31, 0x06	; 6
 a76:	80 81       	ld	r24, Z
 a78:	84 60       	ori	r24, 0x04	; 4
 a7a:	80 83       	st	Z, r24
     ADC0_MUXPOS  = 0x1E;    //Audio in: AIN7 at (0x07), Temperature: Internal sensor at (0x1E)
 a7c:	8e e1       	ldi	r24, 0x1E	; 30
 a7e:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
     adc0Chg = 1;
 a82:	81 e0       	ldi	r24, 0x01	; 1
 a84:	80 93 1a 38 	sts	0x381A, r24	; 0x80381a <__data_end>
 a88:	08 95       	ret

00000a8a <SelectAuIn>:
};

// Select "audio" input (0-2.5V)
void SelectAuIn(){
     VREF_CTRLA   = 0x22;    //0x22 for audio in/out (2.5V), 0x12 for temperature in, audio out (1.1V/2.5V)
 a8a:	82 e2       	ldi	r24, 0x22	; 34
 a8c:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
     ADC0_CTRLA   &= ~(ADC_RESSEL_bm);
 a90:	e0 e0       	ldi	r30, 0x00	; 0
 a92:	f6 e0       	ldi	r31, 0x06	; 6
 a94:	80 81       	ld	r24, Z
 a96:	8b 7f       	andi	r24, 0xFB	; 251
 a98:	80 83       	st	Z, r24
     ADC0_MUXPOS  = 0x07;    //Audio in: AIN7 at (0x07), Temperature: Internal sensor at (0x1E)
 a9a:	87 e0       	ldi	r24, 0x07	; 7
 a9c:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
     adc0Chg = 1;
 aa0:	81 e0       	ldi	r24, 0x01	; 1
 aa2:	80 93 1a 38 	sts	0x381A, r24	; 0x80381a <__data_end>
 aa6:	08 95       	ret

00000aa8 <CheckButtons>:
};

//Returns button combination (4LSB) and number of consecutive times this combination is detected. First read should always be ignored! 
uint8_t CheckButtons(uint8_t previousValue){
    uint8_t bADC = (uint8_t)(adcBtns>>4);
 aa8:	20 91 43 38 	lds	r18, 0x3843	; 0x803843 <adcBtns>
 aac:	30 91 44 38 	lds	r19, 0x3844	; 0x803844 <adcBtns+0x1>
    uint8_t bNibble = 0x0F;     //MSB to LSB: Bottom left, top left, top right, bottom right, 0F is error
    
    switch(bADC){
 ab0:	32 95       	swap	r19
 ab2:	22 95       	swap	r18
 ab4:	2f 70       	andi	r18, 0x0F	; 15
 ab6:	23 27       	eor	r18, r19
 ab8:	3f 70       	andi	r19, 0x0F	; 15
 aba:	23 27       	eor	r18, r19
 abc:	33 27       	eor	r19, r19
 abe:	2c 35       	cpi	r18, 0x5C	; 92
 ac0:	31 05       	cpc	r19, r1
 ac2:	d0 f4       	brcc	.+52     	; 0xaf8 <CheckButtons+0x50>
 ac4:	23 35       	cpi	r18, 0x53	; 83
 ac6:	31 05       	cpc	r19, r1
 ac8:	98 f5       	brcc	.+102    	; 0xb30 <CheckButtons+0x88>
 aca:	22 33       	cpi	r18, 0x32	; 50
 acc:	31 05       	cpc	r19, r1
 ace:	50 f4       	brcc	.+20     	; 0xae4 <CheckButtons+0x3c>
 ad0:	2d 32       	cpi	r18, 0x2D	; 45
 ad2:	31 05       	cpc	r19, r1
 ad4:	48 f5       	brcc	.+82     	; 0xb28 <CheckButtons+0x80>
 ad6:	23 52       	subi	r18, 0x23	; 35
 ad8:	31 09       	sbc	r19, r1
 ada:	25 30       	cpi	r18, 0x05	; 5
 adc:	31 05       	cpc	r19, r1
 ade:	08 f4       	brcc	.+2      	; 0xae2 <CheckButtons+0x3a>
 ae0:	42 c0       	rjmp	.+132    	; 0xb66 <CheckButtons+0xbe>
 ae2:	2e c0       	rjmp	.+92     	; 0xb40 <CheckButtons+0x98>
 ae4:	27 33       	cpi	r18, 0x37	; 55
 ae6:	31 05       	cpc	r19, r1
 ae8:	08 f4       	brcc	.+2      	; 0xaec <CheckButtons+0x44>
 aea:	3f c0       	rjmp	.+126    	; 0xb6a <CheckButtons+0xc2>
 aec:	2e 53       	subi	r18, 0x3E	; 62
 aee:	31 09       	sbc	r19, r1
 af0:	27 30       	cpi	r18, 0x07	; 7
 af2:	31 05       	cpc	r19, r1
 af4:	d8 f0       	brcs	.+54     	; 0xb2c <CheckButtons+0x84>
 af6:	24 c0       	rjmp	.+72     	; 0xb40 <CheckButtons+0x98>
 af8:	2a 38       	cpi	r18, 0x8A	; 138
 afa:	31 05       	cpc	r19, r1
 afc:	48 f4       	brcc	.+18     	; 0xb10 <CheckButtons+0x68>
 afe:	29 37       	cpi	r18, 0x79	; 121
 b00:	31 05       	cpc	r19, r1
 b02:	d0 f4       	brcc	.+52     	; 0xb38 <CheckButtons+0x90>
 b04:	23 56       	subi	r18, 0x63	; 99
 b06:	31 09       	sbc	r19, r1
 b08:	2b 30       	cpi	r18, 0x0B	; 11
 b0a:	31 05       	cpc	r19, r1
 b0c:	98 f0       	brcs	.+38     	; 0xb34 <CheckButtons+0x8c>
 b0e:	18 c0       	rjmp	.+48     	; 0xb40 <CheckButtons+0x98>
 b10:	22 3a       	cpi	r18, 0xA2	; 162
 b12:	31 05       	cpc	r19, r1
 b14:	a8 f0       	brcs	.+42     	; 0xb40 <CheckButtons+0x98>
 b16:	2b 3b       	cpi	r18, 0xBB	; 187
 b18:	31 05       	cpc	r19, r1
 b1a:	80 f0       	brcs	.+32     	; 0xb3c <CheckButtons+0x94>
 b1c:	20 5f       	subi	r18, 0xF0	; 240
 b1e:	31 09       	sbc	r19, r1
 b20:	20 31       	cpi	r18, 0x10	; 16
 b22:	31 05       	cpc	r19, r1
 b24:	d8 f0       	brcs	.+54     	; 0xb5c <CheckButtons+0xb4>
 b26:	0c c0       	rjmp	.+24     	; 0xb40 <CheckButtons+0x98>
        case 35 ... 39:          //37: Both left
        bNibble = 0b1100;
        break;

        case 45 ... 49:          //47: Both bottom
        bNibble = 0b1001;
 b28:	99 e0       	ldi	r25, 0x09	; 9
 b2a:	20 c0       	rjmp	.+64     	; 0xb6c <CheckButtons+0xc4>
        case 50 ... 54:          //52: Bottom left
        bNibble = 0b1000;
        break;

        case 62 ... 68:          //65: Both top
        bNibble = 0b0110;
 b2c:	96 e0       	ldi	r25, 0x06	; 6
        break;
 b2e:	1e c0       	rjmp	.+60     	; 0xb6c <CheckButtons+0xc4>

        case 83 ... 91:          //87: Top left
        bNibble = 0b0100;
 b30:	94 e0       	ldi	r25, 0x04	; 4
        break;
 b32:	1c c0       	rjmp	.+56     	; 0xb6c <CheckButtons+0xc4>

        case 99 ... 109:         //104: Both right
        bNibble = 0b0011;
 b34:	93 e0       	ldi	r25, 0x03	; 3
        break;
 b36:	1a c0       	rjmp	.+52     	; 0xb6c <CheckButtons+0xc4>

        case 121 ... 137:        //129: Top right
        bNibble = 0b0010;
 b38:	92 e0       	ldi	r25, 0x02	; 2
        break;
 b3a:	18 c0       	rjmp	.+48     	; 0xb6c <CheckButtons+0xc4>

        case 162 ... 186:        //174: Bottom right
        bNibble = 0b0001;
 b3c:	91 e0       	ldi	r25, 0x01	; 1
        break;
 b3e:	16 c0       	rjmp	.+44     	; 0xb6c <CheckButtons+0xc4>
        case 240 ... 255:        //255: No button pressed
        bNibble = 0b0000;
        break;
    }

    if ((previousValue&0x0F)==bNibble){
 b40:	98 2f       	mov	r25, r24
 b42:	9f 70       	andi	r25, 0x0F	; 15
 b44:	9f 30       	cpi	r25, 0x0F	; 15
 b46:	41 f4       	brne	.+16     	; 0xb58 <CheckButtons+0xb0>
        if ((previousValue&0xF0) < 0xF0) previousValue += 0x10; //Same value? Increase time nibble
 b48:	28 2f       	mov	r18, r24
 b4a:	20 7f       	andi	r18, 0xF0	; 240
 b4c:	30 e0       	ldi	r19, 0x00	; 0
 b4e:	20 3f       	cpi	r18, 0xF0	; 240
 b50:	31 05       	cpc	r19, r1
 b52:	8c f4       	brge	.+34     	; 0xb76 <CheckButtons+0xce>
 b54:	80 5f       	subi	r24, 0xF0	; 240
 b56:	08 95       	ret
};

//Returns button combination (4LSB) and number of consecutive times this combination is detected. First read should always be ignored! 
uint8_t CheckButtons(uint8_t previousValue){
    uint8_t bADC = (uint8_t)(adcBtns>>4);
    uint8_t bNibble = 0x0F;     //MSB to LSB: Bottom left, top left, top right, bottom right, 0F is error
 b58:	8f e0       	ldi	r24, 0x0F	; 15
 b5a:	08 95       	ret
        case 240 ... 255:        //255: No button pressed
        bNibble = 0b0000;
        break;
    }

    if ((previousValue&0x0F)==bNibble){
 b5c:	98 2f       	mov	r25, r24
 b5e:	9f 70       	andi	r25, 0x0F	; 15
 b60:	99 f3       	breq	.-26     	; 0xb48 <CheckButtons+0xa0>
        if ((previousValue&0xF0) < 0xF0) previousValue += 0x10; //Same value? Increase time nibble
        return previousValue;       
    } else if (bNibble == 0) return 0xFF; //Buttons released, 0xFF triggers readout, previousValue holds last button value.
 b62:	8f ef       	ldi	r24, 0xFF	; 255
 b64:	08 95       	ret
        case 28 ... 32:         //30: All buttons pressed
        bNibble = 0b1111;
        break;

        case 35 ... 39:          //37: Both left
        bNibble = 0b1100;
 b66:	9c e0       	ldi	r25, 0x0C	; 12
 b68:	01 c0       	rjmp	.+2      	; 0xb6c <CheckButtons+0xc4>
        case 45 ... 49:          //47: Both bottom
        bNibble = 0b1001;
        break;

        case 50 ... 54:          //52: Bottom left
        bNibble = 0b1000;
 b6a:	98 e0       	ldi	r25, 0x08	; 8
        case 240 ... 255:        //255: No button pressed
        bNibble = 0b0000;
        break;
    }

    if ((previousValue&0x0F)==bNibble){
 b6c:	28 2f       	mov	r18, r24
 b6e:	2f 70       	andi	r18, 0x0F	; 15
 b70:	92 17       	cp	r25, r18
 b72:	51 f3       	breq	.-44     	; 0xb48 <CheckButtons+0xa0>
 b74:	89 2f       	mov	r24, r25
        if ((previousValue&0xF0) < 0xF0) previousValue += 0x10; //Same value? Increase time nibble
        return previousValue;       
    } else if (bNibble == 0) return 0xFF; //Buttons released, 0xFF triggers readout, previousValue holds last button value.
              else return bNibble;  //New value  
}
 b76:	08 95       	ret

00000b78 <DecryptData>:
uint8_t CheckInput(){
    return 0;
}

//The game logic!
void ProcessInput(){
 b78:	cf 93       	push	r28
 b7a:	df 93       	push	r29
 b7c:	dc 01       	movw	r26, r24
 b7e:	e9 01       	movw	r28, r18
 b80:	66 23       	and	r22, r22
 b82:	a9 f0       	breq	.+42     	; 0xbae <DecryptData+0x36>
 b84:	50 e0       	ldi	r21, 0x00	; 0
 b86:	90 97       	sbiw	r26, 0x20	; 32
 b88:	fd 01       	movw	r30, r26
 b8a:	e7 70       	andi	r30, 0x07	; 7
 b8c:	ff 27       	eor	r31, r31
 b8e:	ee 0f       	add	r30, r30
 b90:	ff 1f       	adc	r31, r31
 b92:	ee 0f       	add	r30, r30
 b94:	ff 1f       	adc	r31, r31
 b96:	ee 0f       	add	r30, r30
 b98:	ff 1f       	adc	r31, r31
 b9a:	e4 5d       	subi	r30, 0xD4	; 212
 b9c:	f0 47       	sbci	r31, 0x70	; 112
 b9e:	e4 0f       	add	r30, r20
 ba0:	f5 1f       	adc	r31, r21
 ba2:	88 81       	ld	r24, Y
 ba4:	90 81       	ld	r25, Z
 ba6:	98 27       	eor	r25, r24
 ba8:	99 93       	st	Y+, r25
 baa:	61 50       	subi	r22, 0x01	; 1
 bac:	61 f7       	brne	.-40     	; 0xb86 <DecryptData+0xe>
 bae:	df 91       	pop	r29
 bb0:	cf 91       	pop	r28
 bb2:	08 95       	ret

00000bb4 <ExtEERead>:
 bb4:	af 92       	push	r10
 bb6:	bf 92       	push	r11
 bb8:	cf 92       	push	r12
 bba:	df 92       	push	r13
 bbc:	ef 92       	push	r14
 bbe:	ff 92       	push	r15
 bc0:	0f 93       	push	r16
 bc2:	1f 93       	push	r17
 bc4:	cf 93       	push	r28
 bc6:	df 93       	push	r29
 bc8:	00 d0       	rcall	.+0      	; 0xbca <ExtEERead+0x16>
 bca:	cd b7       	in	r28, 0x3d	; 61
 bcc:	de b7       	in	r29, 0x3e	; 62
 bce:	d6 2e       	mov	r13, r22
 bd0:	c4 2e       	mov	r12, r20
 bd2:	59 01       	movw	r10, r18
 bd4:	80 96       	adiw	r24, 0x20	; 32
 bd6:	7c 01       	movw	r14, r24
 bd8:	e8 94       	clt
 bda:	f7 f8       	bld	r15, 7
 bdc:	f9 82       	std	Y+1, r15	; 0x01
 bde:	ea 82       	std	Y+2, r14	; 0x02
 be0:	06 2f       	mov	r16, r22
 be2:	42 e0       	ldi	r20, 0x02	; 2
 be4:	be 01       	movw	r22, r28
 be6:	6f 5f       	subi	r22, 0xFF	; 255
 be8:	7f 4f       	sbci	r23, 0xFF	; 255
 bea:	80 e5       	ldi	r24, 0x50	; 80
 bec:	59 db       	rcall	.-2382   	; 0x2a0 <I2C_read_bytes>
 bee:	18 2f       	mov	r17, r24
 bf0:	81 11       	cpse	r24, r1
 bf2:	05 c0       	rjmp	.+10     	; 0xbfe <ExtEERead+0x4a>
 bf4:	95 01       	movw	r18, r10
 bf6:	4c 2d       	mov	r20, r12
 bf8:	6d 2d       	mov	r22, r13
 bfa:	c7 01       	movw	r24, r14
 bfc:	bd df       	rcall	.-134    	; 0xb78 <DecryptData>
 bfe:	81 2f       	mov	r24, r17
 c00:	0f 90       	pop	r0
 c02:	0f 90       	pop	r0
 c04:	df 91       	pop	r29
 c06:	cf 91       	pop	r28
 c08:	1f 91       	pop	r17
 c0a:	0f 91       	pop	r16
 c0c:	ff 90       	pop	r15
 c0e:	ef 90       	pop	r14
 c10:	df 90       	pop	r13
 c12:	cf 90       	pop	r12
 c14:	bf 90       	pop	r11
 c16:	af 90       	pop	r10
 c18:	08 95       	ret

00000c1a <CheckSend>:
 c1a:	0f 93       	push	r16
 c1c:	1f 93       	push	r17
 c1e:	cf 93       	push	r28
 c20:	80 91 1f 38 	lds	r24, 0x381F	; 0x80381f <txAddrNow>
 c24:	88 30       	cpi	r24, 0x08	; 8
 c26:	08 f0       	brcs	.+2      	; 0xc2a <CheckSend+0x10>
 c28:	44 c0       	rjmp	.+136    	; 0xcb2 <CheckSend+0x98>
 c2a:	90 91 00 38 	lds	r25, 0x3800	; 0x803800 <__data_start>
 c2e:	99 23       	and	r25, r25
 c30:	09 f4       	brne	.+2      	; 0xc34 <CheckSend+0x1a>
 c32:	3f c0       	rjmp	.+126    	; 0xcb2 <CheckSend+0x98>
 c34:	28 2f       	mov	r18, r24
 c36:	30 e0       	ldi	r19, 0x00	; 0
 c38:	f9 01       	movw	r30, r18
 c3a:	ef 5f       	subi	r30, 0xFF	; 255
 c3c:	f7 4c       	sbci	r31, 0xC7	; 199
 c3e:	00 81       	ld	r16, Z
 c40:	90 91 1e 38 	lds	r25, 0x381E	; 0x80381e <txPart.3927>
 c44:	90 17       	cp	r25, r16
 c46:	28 f5       	brcc	.+74     	; 0xc92 <CheckSend+0x78>
 c48:	10 e0       	ldi	r17, 0x00	; 0
 c4a:	09 1b       	sub	r16, r25
 c4c:	11 09       	sbc	r17, r1
 c4e:	0f 71       	andi	r16, 0x1F	; 31
 c50:	10 78       	andi	r17, 0x80	; 128
 c52:	11 23       	and	r17, r17
 c54:	34 f4       	brge	.+12     	; 0xc62 <CheckSend+0x48>
 c56:	01 50       	subi	r16, 0x01	; 1
 c58:	11 09       	sbc	r17, r1
 c5a:	00 6e       	ori	r16, 0xE0	; 224
 c5c:	1f 6f       	ori	r17, 0xFF	; 255
 c5e:	0f 5f       	subi	r16, 0xFF	; 255
 c60:	1f 4f       	sbci	r17, 0xFF	; 255
 c62:	c0 2f       	mov	r28, r16
 c64:	22 0f       	add	r18, r18
 c66:	33 1f       	adc	r19, r19
 c68:	f9 01       	movw	r30, r18
 c6a:	e7 5f       	subi	r30, 0xF7	; 247
 c6c:	f7 4c       	sbci	r31, 0xC7	; 199
 c6e:	01 90       	ld	r0, Z+
 c70:	f0 81       	ld	r31, Z
 c72:	e0 2d       	mov	r30, r0
 c74:	28 e9       	ldi	r18, 0x98	; 152
 c76:	38 e3       	ldi	r19, 0x38	; 56
 c78:	40 e0       	ldi	r20, 0x00	; 0
 c7a:	60 2f       	mov	r22, r16
 c7c:	df 01       	movw	r26, r30
 c7e:	a9 0f       	add	r26, r25
 c80:	b1 1d       	adc	r27, r1
 c82:	cd 01       	movw	r24, r26
 c84:	97 df       	rcall	.-210    	; 0xbb4 <ExtEERead>
 c86:	80 91 1e 38 	lds	r24, 0x381E	; 0x80381e <txPart.3927>
 c8a:	08 0f       	add	r16, r24
 c8c:	00 93 1e 38 	sts	0x381E, r16	; 0x80381e <txPart.3927>
 c90:	06 c0       	rjmp	.+12     	; 0xc9e <CheckSend+0x84>
 c92:	10 92 1e 38 	sts	0x381E, r1	; 0x80381e <txPart.3927>
 c96:	8f 5f       	subi	r24, 0xFF	; 255
 c98:	80 93 1f 38 	sts	0x381F, r24	; 0x80381f <txAddrNow>
 c9c:	c0 e0       	ldi	r28, 0x00	; 0
 c9e:	ec 2f       	mov	r30, r28
 ca0:	f0 e0       	ldi	r31, 0x00	; 0
 ca2:	e8 56       	subi	r30, 0x68	; 104
 ca4:	f7 4c       	sbci	r31, 0xC7	; 199
 ca6:	10 82       	st	Z, r1
 ca8:	88 e9       	ldi	r24, 0x98	; 152
 caa:	98 e3       	ldi	r25, 0x38	; 56
 cac:	bc de       	rcall	.-648    	; 0xa26 <SerSend>
 cae:	81 e0       	ldi	r24, 0x01	; 1
 cb0:	05 c0       	rjmp	.+10     	; 0xcbc <CheckSend+0xa2>
 cb2:	90 91 00 38 	lds	r25, 0x3800	; 0x803800 <__data_start>
 cb6:	81 e0       	ldi	r24, 0x01	; 1
 cb8:	91 11       	cpse	r25, r1
 cba:	80 e0       	ldi	r24, 0x00	; 0
 cbc:	cf 91       	pop	r28
 cbe:	1f 91       	pop	r17
 cc0:	0f 91       	pop	r16
 cc2:	08 95       	ret

00000cc4 <TextAdventure>:
}


// Main game loop
uint8_t TextAdventure(){
    if (CheckSend()) return 1;          //Still sending data to serial, return 1
 cc4:	aa df       	rcall	.-172    	; 0xc1a <CheckSend>
 cc6:	81 11       	cpse	r24, r1
 cc8:	02 c0       	rjmp	.+4      	; 0xcce <TextAdventure+0xa>
    if (CheckInput() == 0) return 2;    //No input to process, return 2
 cca:	82 e0       	ldi	r24, 0x02	; 2
 ccc:	08 95       	ret
}


// Main game loop
uint8_t TextAdventure(){
    if (CheckSend()) return 1;          //Still sending data to serial, return 1
 cce:	81 e0       	ldi	r24, 0x01	; 1
    if (CheckInput() == 0) return 2;    //No input to process, return 2
    ProcessInput();
    return 0;
 cd0:	08 95       	ret

00000cd2 <main>:



//This is where it begins, inits first and main program in while(1) loop.
int main(void)
{
 cd2:	cf 93       	push	r28
 cd4:	df 93       	push	r29
 cd6:	cd b7       	in	r28, 0x3d	; 61
 cd8:	de b7       	in	r29, 0x3e	; 62
 cda:	a7 97       	sbiw	r28, 0x27	; 39
 cdc:	cd bf       	out	0x3d, r28	; 61
 cde:	de bf       	out	0x3e, r29	; 62
    setup();
 ce0:	83 db       	rcall	.-2298   	; 0x3e8 <setup>

    unsigned char strTest[]="\aHckerHotel2020 badge pest!\b\b\b\b\bt\n";
 ce2:	84 e2       	ldi	r24, 0x24	; 36
 ce4:	ec e3       	ldi	r30, 0x3C	; 60
 ce6:	ff e8       	ldi	r31, 0x8F	; 143
 ce8:	de 01       	movw	r26, r28
 cea:	11 96       	adiw	r26, 0x01	; 1
 cec:	01 90       	ld	r0, Z+
 cee:	0d 92       	st	X+, r0
 cf0:	8a 95       	dec	r24
 cf2:	e1 f7       	brne	.-8      	; 0xcec <main+0x1a>
    SerSend(&strTest[0]);
 cf4:	ce 01       	movw	r24, r28
 cf6:	01 96       	adiw	r24, 0x01	; 1
 cf8:	96 de       	rcall	.-724    	; 0xa26 <SerSend>

    //I2C 
    uint8_t devAddr = 0x50;
    uint8_t memAddr[2] = {0,0};
 cfa:	1d a2       	std	Y+37, r1	; 0x25
 cfc:	1e a2       	std	Y+38, r1	; 0x26
    volatile uint8_t retVal = 0;
 cfe:	1f a2       	std	Y+39, r1	; 0x27
    uint8_t btns = 0;
    uint8_t bla = 0;

    if (I2C_write_bytes(devAddr, &memAddr[0], 2, &strTest[0], sizeof(strTest))) retVal = 0xFA;
 d00:	04 e2       	ldi	r16, 0x24	; 36
 d02:	9e 01       	movw	r18, r28
 d04:	2f 5f       	subi	r18, 0xFF	; 255
 d06:	3f 4f       	sbci	r19, 0xFF	; 255
 d08:	42 e0       	ldi	r20, 0x02	; 2
 d0a:	be 01       	movw	r22, r28
 d0c:	6b 5d       	subi	r22, 0xDB	; 219
 d0e:	7f 4f       	sbci	r23, 0xFF	; 255
 d10:	80 e5       	ldi	r24, 0x50	; 80
 d12:	1e db       	rcall	.-2500   	; 0x350 <I2C_write_bytes>
 d14:	88 23       	and	r24, r24
 d16:	11 f0       	breq	.+4      	; 0xd1c <main+0x4a>
 d18:	8a ef       	ldi	r24, 0xFA	; 250
    SerSpeed(255);
 d1a:	8f a3       	std	Y+39, r24	; 0x27
 d1c:	8f ef       	ldi	r24, 0xFF	; 255
 d1e:	95 de       	rcall	.-726    	; 0xa4a <SerSpeed>

    //Do some LED tests
    for (uint8_t n=0; n<40; n++){
 d20:	80 e0       	ldi	r24, 0x00	; 0
        if ((n%8)>5) n+=2;
        if (n<40) iLED[n] = 255;
 d22:	2f ef       	ldi	r18, 0xFF	; 255
 d24:	07 c0       	rjmp	.+14     	; 0xd34 <main+0x62>
    if (I2C_write_bytes(devAddr, &memAddr[0], 2, &strTest[0], sizeof(strTest))) retVal = 0xFA;
    SerSpeed(255);

    //Do some LED tests
    for (uint8_t n=0; n<40; n++){
        if ((n%8)>5) n+=2;
 d26:	39 2f       	mov	r19, r25
 d28:	37 70       	andi	r19, 0x07	; 7
 d2a:	36 30       	cpi	r19, 0x06	; 6
 d2c:	10 f0       	brcs	.+4      	; 0xd32 <main+0x60>
 d2e:	93 e0       	ldi	r25, 0x03	; 3
 d30:	98 0f       	add	r25, r24



//This is where it begins, inits first and main program in while(1) loop.
int main(void)
{
 d32:	89 2f       	mov	r24, r25
    SerSpeed(255);

    //Do some LED tests
    for (uint8_t n=0; n<40; n++){
        if ((n%8)>5) n+=2;
        if (n<40) iLED[n] = 255;
 d34:	88 32       	cpi	r24, 0x28	; 40
 d36:	08 f0       	brcs	.+2      	; 0xd3a <main+0x68>
 d38:	d9 c0       	rjmp	.+434    	; 0xeec <main+0x21a>
 d3a:	e8 2f       	mov	r30, r24
 d3c:	f0 e0       	ldi	r31, 0x00	; 0
 d3e:	e4 59       	subi	r30, 0x94	; 148
 d40:	f7 4c       	sbci	r31, 0xC7	; 199
 d42:	20 83       	st	Z, r18
 d44:	d3 c0       	rjmp	.+422    	; 0xeec <main+0x21a>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 d46:	a7 ea       	ldi	r26, 0xA7	; 167
 d48:	b1 e6       	ldi	r27, 0x61	; 97
 d4a:	11 97       	sbiw	r26, 0x01	; 1
 d4c:	f1 f7       	brne	.-4      	; 0xd4a <main+0x78>
 d4e:	00 c0       	rjmp	.+0      	; 0xd50 <main+0x7e>
 d50:	00 00       	nop
 d52:	91 50       	subi	r25, 0x01	; 1
        for(uint8_t b=0; b<10; b++)_delay_ms(10);
 d54:	c1 f7       	brne	.-16     	; 0xd46 <main+0x74>

    if (I2C_write_bytes(devAddr, &memAddr[0], 2, &strTest[0], sizeof(strTest))) retVal = 0xFA;
    SerSpeed(255);

    //Do some LED tests
    for (uint8_t n=0; n<40; n++){
 d56:	91 e0       	ldi	r25, 0x01	; 1
 d58:	98 0f       	add	r25, r24
 d5a:	98 32       	cpi	r25, 0x28	; 40
 d5c:	20 f3       	brcs	.-56     	; 0xd26 <main+0x54>
 d5e:	80 e0       	ldi	r24, 0x00	; 0
 d60:	07 c0       	rjmp	.+14     	; 0xd70 <main+0x9e>
        if ((n%8)>5) n+=2;
        if (n<40) iLED[n] = 255;
        for(uint8_t b=0; b<10; b++)_delay_ms(10);
    }
    for (uint8_t n=0; n<40; n++){
        if ((n%8)>5) n+=2;
 d62:	29 2f       	mov	r18, r25
 d64:	27 70       	andi	r18, 0x07	; 7
 d66:	26 30       	cpi	r18, 0x06	; 6
 d68:	10 f0       	brcs	.+4      	; 0xd6e <main+0x9c>
 d6a:	93 e0       	ldi	r25, 0x03	; 3
 d6c:	98 0f       	add	r25, r24
 d6e:	89 2f       	mov	r24, r25
        if (n<40) iLED[n] = 0;
 d70:	88 32       	cpi	r24, 0x28	; 40
 d72:	08 f0       	brcs	.+2      	; 0xd76 <main+0xa4>
 d74:	bd c0       	rjmp	.+378    	; 0xef0 <main+0x21e>
 d76:	e8 2f       	mov	r30, r24
 d78:	f0 e0       	ldi	r31, 0x00	; 0
 d7a:	e4 59       	subi	r30, 0x94	; 148
 d7c:	f7 4c       	sbci	r31, 0xC7	; 199
 d7e:	10 82       	st	Z, r1
 d80:	b7 c0       	rjmp	.+366    	; 0xef0 <main+0x21e>
 d82:	e7 ea       	ldi	r30, 0xA7	; 167
 d84:	f1 e6       	ldi	r31, 0x61	; 97
 d86:	31 97       	sbiw	r30, 0x01	; 1
 d88:	f1 f7       	brne	.-4      	; 0xd86 <main+0xb4>
 d8a:	00 c0       	rjmp	.+0      	; 0xd8c <main+0xba>
 d8c:	00 00       	nop
 d8e:	91 50       	subi	r25, 0x01	; 1
        for(uint8_t b=0; b<10; b++)_delay_ms(10);
 d90:	c1 f7       	brne	.-16     	; 0xd82 <main+0xb0>
    for (uint8_t n=0; n<40; n++){
        if ((n%8)>5) n+=2;
        if (n<40) iLED[n] = 255;
        for(uint8_t b=0; b<10; b++)_delay_ms(10);
    }
    for (uint8_t n=0; n<40; n++){
 d92:	91 e0       	ldi	r25, 0x01	; 1
 d94:	98 0f       	add	r25, r24
 d96:	98 32       	cpi	r25, 0x28	; 40
 d98:	20 f3       	brcs	.-56     	; 0xd62 <main+0x90>
 d9a:	22 e2       	ldi	r18, 0x22	; 34
 d9c:	3f e8       	ldi	r19, 0x8F	; 143
 d9e:	ac e2       	ldi	r26, 0x2C	; 44
 da0:	bf e8       	ldi	r27, 0x8F	; 143
 da2:	80 e0       	ldi	r24, 0x00	; 0
 da4:	90 e0       	ldi	r25, 0x00	; 0
        if ((n%8)>5) n+=2;
        if (n<40) iLED[n] = 0;
        for(uint8_t b=0; b<10; b++)_delay_ms(10);
    }
    for (uint8_t n=0; n<5; n++){
        iLED[WING[R][n]] = 1<<n;
 da6:	41 e0       	ldi	r20, 0x01	; 1
 da8:	50 e0       	ldi	r21, 0x00	; 0
 daa:	f9 01       	movw	r30, r18
 dac:	61 91       	ld	r22, Z+
 dae:	9f 01       	movw	r18, r30
 db0:	e6 2f       	mov	r30, r22
 db2:	f0 e0       	ldi	r31, 0x00	; 0
 db4:	e4 59       	subi	r30, 0x94	; 148
 db6:	f7 4c       	sbci	r31, 0xC7	; 199
 db8:	ba 01       	movw	r22, r20
 dba:	08 2e       	mov	r0, r24
 dbc:	02 c0       	rjmp	.+4      	; 0xdc2 <main+0xf0>
 dbe:	66 0f       	add	r22, r22
 dc0:	77 1f       	adc	r23, r23
 dc2:	0a 94       	dec	r0
 dc4:	e2 f7       	brpl	.-8      	; 0xdbe <main+0xec>
 dc6:	60 83       	st	Z, r22
        iLED[WING[L][4-n]] = 1<<n;
 dc8:	ee 91       	ld	r30, -X
 dca:	f0 e0       	ldi	r31, 0x00	; 0
 dcc:	e4 59       	subi	r30, 0x94	; 148
 dce:	f7 4c       	sbci	r31, 0xC7	; 199
 dd0:	60 83       	st	Z, r22
 dd2:	6a e0       	ldi	r22, 0x0A	; 10
 dd4:	e7 ea       	ldi	r30, 0xA7	; 167
 dd6:	f1 e6       	ldi	r31, 0x61	; 97
 dd8:	31 97       	sbiw	r30, 0x01	; 1
 dda:	f1 f7       	brne	.-4      	; 0xdd8 <main+0x106>
 ddc:	00 c0       	rjmp	.+0      	; 0xdde <main+0x10c>
 dde:	00 00       	nop
 de0:	61 50       	subi	r22, 0x01	; 1
        for(uint8_t b=0; b<10; b++)_delay_ms(10);
 de2:	c1 f7       	brne	.-16     	; 0xdd4 <main+0x102>
 de4:	01 96       	adiw	r24, 0x01	; 1
    for (uint8_t n=0; n<40; n++){
        if ((n%8)>5) n+=2;
        if (n<40) iLED[n] = 0;
        for(uint8_t b=0; b<10; b++)_delay_ms(10);
    }
    for (uint8_t n=0; n<5; n++){
 de6:	85 30       	cpi	r24, 0x05	; 5
 de8:	91 05       	cpc	r25, r1
 dea:	f9 f6       	brne	.-66     	; 0xdaa <main+0xd8>
        iLED[WING[R][n]] = 1<<n;
        iLED[WING[L][4-n]] = 1<<n;
        for(uint8_t b=0; b<10; b++)_delay_ms(10);
    }

    iLED[GEM[R]] = 255;
 dec:	a0 e2       	ldi	r26, 0x20	; 32
 dee:	bf e8       	ldi	r27, 0x8F	; 143
 df0:	ec 91       	ld	r30, X
 df2:	f0 e0       	ldi	r31, 0x00	; 0
 df4:	e4 59       	subi	r30, 0x94	; 148
 df6:	f7 4c       	sbci	r31, 0xC7	; 199
 df8:	8f ef       	ldi	r24, 0xFF	; 255
 dfa:	80 83       	st	Z, r24
    iLED[GEM[L]] = 63;
 dfc:	11 96       	adiw	r26, 0x01	; 1
 dfe:	ec 91       	ld	r30, X
 e00:	f0 e0       	ldi	r31, 0x00	; 0
 e02:	e4 59       	subi	r30, 0x94	; 148
 e04:	f7 4c       	sbci	r31, 0xC7	; 199
 e06:	8f e3       	ldi	r24, 0x3F	; 63
 e08:	80 83       	st	Z, r24

    if (EEWrite(16, &strTest[0], sizeof(strTest))) retVal = 0xFA;     //Internal EEPROM write test
 e0a:	44 e2       	ldi	r20, 0x24	; 36
 e0c:	be 01       	movw	r22, r28
 e0e:	6f 5f       	subi	r22, 0xFF	; 255
 e10:	7f 4f       	sbci	r23, 0xFF	; 255
 e12:	80 e1       	ldi	r24, 0x10	; 16
 e14:	bf dd       	rcall	.-1154   	; 0x994 <EEWrite>
 e16:	88 23       	and	r24, r24
 e18:	11 f0       	breq	.+4      	; 0xe1e <main+0x14c>
 e1a:	8a ef       	ldi	r24, 0xFA	; 250
 e1c:	8f a3       	std	Y+39, r24	; 0x27
        if (n<40) iLED[n] = 0;
        for(uint8_t b=0; b<10; b++)_delay_ms(10);
    }
    for (uint8_t n=0; n<5; n++){
        iLED[WING[R][n]] = 1<<n;
        iLED[WING[L][4-n]] = 1<<n;
 e1e:	d1 2c       	mov	r13, r1
 e20:	c1 2c       	mov	r12, r1
    while (1)
    {
        //serRxDone is 1 when a LF character is detected
        if (serRxDone) {
            while (serTxDone == 0);
            if (SerSend((uint8_t*) &serRx[0])) retVal = 0xFA; //Echo back using the serRx buffer (which is abused here and further on in code too for sending stuff, I'm lazy...)
 e22:	1a ef       	ldi	r17, 0xFA	; 250
            
            //Send test sensor values
            serRx[1] = (unsigned char)(adcHall>>4);
            serRx[2] = (unsigned char)(adcPhot>>4);
            serRx[3] = (unsigned char)(adcTemp);
            serRx[4] = (unsigned char)(auIn[0]);            
 e24:	0f 2e       	mov	r0, r31
 e26:	fc e4       	ldi	r31, 0x4C	; 76
 e28:	ef 2e       	mov	r14, r31
 e2a:	f8 e3       	ldi	r31, 0x38	; 56
 e2c:	ff 2e       	mov	r15, r31
 e2e:	f0 2d       	mov	r31, r0
    if (EEWrite(16, &strTest[0], sizeof(strTest))) retVal = 0xFA;     //Internal EEPROM write test

    while (1)
    {
        //serRxDone is 1 when a LF character is detected
        if (serRxDone) {
 e30:	80 91 1d 38 	lds	r24, 0x381D	; 0x80381d <serRxDone>
 e34:	88 23       	and	r24, r24
 e36:	61 f0       	breq	.+24     	; 0xe50 <main+0x17e>
            while (serTxDone == 0);
 e38:	80 91 00 38 	lds	r24, 0x3800	; 0x803800 <__data_start>
 e3c:	88 23       	and	r24, r24
            if (SerSend((uint8_t*) &serRx[0])) retVal = 0xFA; //Echo back using the serRx buffer (which is abused here and further on in code too for sending stuff, I'm lazy...)
 e3e:	e1 f3       	breq	.-8      	; 0xe38 <main+0x166>
 e40:	81 e2       	ldi	r24, 0x21	; 33
 e42:	98 e3       	ldi	r25, 0x38	; 56
 e44:	f0 dd       	rcall	.-1056   	; 0xa26 <SerSend>
 e46:	81 11       	cpse	r24, r1
 e48:	1f a3       	std	Y+39, r17	; 0x27
            RXCNT = 0;
 e4a:	1d ba       	out	0x1d, r1	; 29
            serRxDone = 0;         
 e4c:	10 92 1d 38 	sts	0x381D, r1	; 0x80381d <serRxDone>
        }

        //buttonMark is updated by hardware timer, every increment there is a new button value available  
        if (buttonMark){
 e50:	80 91 1b 38 	lds	r24, 0x381B	; 0x80381b <buttonMark>
 e54:	88 23       	and	r24, r24
            serRx[0] = CheckButtons(btns); //Reading buttons and duration is done by passing old value to the function, return value is the new readout.
 e56:	61 f3       	breq	.-40     	; 0xe30 <main+0x15e>
 e58:	8c 2d       	mov	r24, r12
 e5a:	26 de       	rcall	.-948    	; 0xaa8 <CheckButtons>
 e5c:	e1 e2       	ldi	r30, 0x21	; 33
 e5e:	f8 e3       	ldi	r31, 0x38	; 56
            /*
                Check if button value has changed here
            */
            btns = serRx[0]; 
 e60:	80 83       	st	Z, r24
            buttonMark = 0;
 e62:	c0 80       	ld	r12, Z

            bla++;
 e64:	10 92 1b 38 	sts	0x381B, r1	; 0x80381b <buttonMark>
            if (bla%2) SelectAuIn(); else SelectTSens();    //Switch between audio in and temperature for testing
 e68:	d3 94       	inc	r13
 e6a:	d0 fe       	sbrs	r13, 0
 e6c:	02 c0       	rjmp	.+4      	; 0xe72 <main+0x1a0>
 e6e:	0d de       	rcall	.-998    	; 0xa8a <SelectAuIn>
 e70:	01 c0       	rjmp	.+2      	; 0xe74 <main+0x1a2>
 e72:	fc dd       	rcall	.-1032   	; 0xa6c <SelectTSens>
            
            //Send test sensor values
            serRx[1] = (unsigned char)(adcHall>>4);
 e74:	80 91 47 38 	lds	r24, 0x3847	; 0x803847 <adcHall>
 e78:	90 91 48 38 	lds	r25, 0x3848	; 0x803848 <adcHall+0x1>
 e7c:	92 95       	swap	r25
 e7e:	82 95       	swap	r24
 e80:	8f 70       	andi	r24, 0x0F	; 15
 e82:	89 27       	eor	r24, r25
 e84:	9f 70       	andi	r25, 0x0F	; 15
 e86:	89 27       	eor	r24, r25
 e88:	e1 e2       	ldi	r30, 0x21	; 33
 e8a:	f8 e3       	ldi	r31, 0x38	; 56
 e8c:	81 83       	std	Z+1, r24	; 0x01
            serRx[2] = (unsigned char)(adcPhot>>4);
 e8e:	80 91 49 38 	lds	r24, 0x3849	; 0x803849 <adcPhot>
 e92:	90 91 4a 38 	lds	r25, 0x384A	; 0x80384a <adcPhot+0x1>
 e96:	92 95       	swap	r25
 e98:	82 95       	swap	r24
 e9a:	8f 70       	andi	r24, 0x0F	; 15
 e9c:	89 27       	eor	r24, r25
 e9e:	9f 70       	andi	r25, 0x0F	; 15
 ea0:	89 27       	eor	r24, r25
 ea2:	82 83       	std	Z+2, r24	; 0x02
            serRx[3] = (unsigned char)(adcTemp);
 ea4:	80 91 95 38 	lds	r24, 0x3895	; 0x803895 <adcTemp>
 ea8:	83 83       	std	Z+3, r24	; 0x03
            serRx[4] = (unsigned char)(auIn[0]);            
 eaa:	d7 01       	movw	r26, r14
 eac:	8c 91       	ld	r24, X
            serRx[5] = (unsigned char) minuteMark;
 eae:	84 83       	std	Z+4, r24	; 0x04
 eb0:	80 91 1c 38 	lds	r24, 0x381C	; 0x80381c <minuteMark>
            EERead(17, (uint8_t*)&serRx[6], 1);                                                   //"H" character (second char of strTest)
 eb4:	85 83       	std	Z+5, r24	; 0x05
 eb6:	41 e0       	ldi	r20, 0x01	; 1
 eb8:	67 e2       	ldi	r22, 0x27	; 39
 eba:	78 e3       	ldi	r23, 0x38	; 56
 ebc:	81 e1       	ldi	r24, 0x11	; 17
            if (I2C_read_bytes(devAddr, &memAddr[0], 2, (uint8_t*)&serRx[7], 1)) retVal = 0xFA;   //Bell character (first char of strTest)
 ebe:	57 dd       	rcall	.-1362   	; 0x96e <EERead>
 ec0:	01 e0       	ldi	r16, 0x01	; 1
 ec2:	28 e2       	ldi	r18, 0x28	; 40
 ec4:	38 e3       	ldi	r19, 0x38	; 56
 ec6:	42 e0       	ldi	r20, 0x02	; 2
 ec8:	be 01       	movw	r22, r28
 eca:	6b 5d       	subi	r22, 0xDB	; 219
 ecc:	7f 4f       	sbci	r23, 0xFF	; 255
 ece:	80 e5       	ldi	r24, 0x50	; 80
 ed0:	e7 d9       	rcall	.-3122   	; 0x2a0 <I2C_read_bytes>
 ed2:	81 11       	cpse	r24, r1
            serRx[8] = retVal;
 ed4:	1f a3       	std	Y+39, r17	; 0x27
 ed6:	8f a1       	ldd	r24, Y+39	; 0x27
 ed8:	80 93 29 38 	sts	0x3829, r24	; 0x803829 <serRx+0x8>
            while (serTxDone == 0);
 edc:	80 91 00 38 	lds	r24, 0x3800	; 0x803800 <__data_start>
 ee0:	88 23       	and	r24, r24
            //SerSend((uint8_t*) &serRx[0]);
            retVal = TextAdventure();
 ee2:	e1 f3       	breq	.-8      	; 0xedc <main+0x20a>
 ee4:	ef de       	rcall	.-546    	; 0xcc4 <TextAdventure>
 ee6:	8f a3       	std	Y+39, r24	; 0x27
            retVal = 0;
 ee8:	1f a2       	std	Y+39, r1	; 0x27
 eea:	a2 cf       	rjmp	.-188    	; 0xe30 <main+0x15e>

    if (I2C_write_bytes(devAddr, &memAddr[0], 2, &strTest[0], sizeof(strTest))) retVal = 0xFA;
    SerSpeed(255);

    //Do some LED tests
    for (uint8_t n=0; n<40; n++){
 eec:	9a e0       	ldi	r25, 0x0A	; 10
 eee:	2b cf       	rjmp	.-426    	; 0xd46 <main+0x74>
 ef0:	9a e0       	ldi	r25, 0x0A	; 10
 ef2:	47 cf       	rjmp	.-370    	; 0xd82 <main+0xb0>

00000ef4 <__udivmodhi4>:
 ef4:	aa 1b       	sub	r26, r26
 ef6:	bb 1b       	sub	r27, r27
 ef8:	51 e1       	ldi	r21, 0x11	; 17
 efa:	07 c0       	rjmp	.+14     	; 0xf0a <__udivmodhi4_ep>

00000efc <__udivmodhi4_loop>:
 efc:	aa 1f       	adc	r26, r26
 efe:	bb 1f       	adc	r27, r27
 f00:	a6 17       	cp	r26, r22
 f02:	b7 07       	cpc	r27, r23
 f04:	10 f0       	brcs	.+4      	; 0xf0a <__udivmodhi4_ep>
 f06:	a6 1b       	sub	r26, r22
 f08:	b7 0b       	sbc	r27, r23

00000f0a <__udivmodhi4_ep>:
 f0a:	88 1f       	adc	r24, r24
 f0c:	99 1f       	adc	r25, r25
 f0e:	5a 95       	dec	r21
 f10:	a9 f7       	brne	.-22     	; 0xefc <__udivmodhi4_loop>
 f12:	80 95       	com	r24
 f14:	90 95       	com	r25
 f16:	bc 01       	movw	r22, r24
 f18:	cd 01       	movw	r24, r26
 f1a:	08 95       	ret

00000f1c <_exit>:
 f1c:	f8 94       	cli

00000f1e <__stop_program>:
 f1e:	ff cf       	rjmp	.-2      	; 0xf1e <__stop_program>
